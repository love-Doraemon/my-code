## 一、王道基本知识点
### （一）大型知识模块
#### 1、 从源代码生成可执行程序包含哪几个步骤，请用自己的话描述每个步骤的作用
##### （1）预处理
**①定义：**
将头文件或者定义的变量和函数进行文本替换，把.h和.c片段结合成.i

**②包含：**
包括头文件包含、宏定义（define）、宏函数，define的值不能改变，且是全局的。

**③define和typedef的区别：**
define是预处理指令，在编译预处理的时进行文本替换，在编译时再一起检错，而typedef是关键字，在编译时使用并进行检错。
define的可以定义变量常量函数等，typedef 用来定义类型的别名。
define没有作用域，定义后整个程序都用，typedef一般只在函数体中作用。
define是替换（不能用之前的了），typedef是别名

**④define和const的区别：**
const的值也不能改变（相同点）。const在编译阶段确定值，并进行安全检查且可以调试（define不行）。如果是定义全局变量，整个只定义在全局静态存储区中一份（define多份）。define没有内存空间这一说，只是在替换。

**⑤const定义全局变量和局部变量**
c语言中const修饰全局变量是存在全局（静态）存储区（只读数据段）（ROM中），c++中的话如果只是值替换则不存入内存，只简单替换，其余和c不变。
c语言中const修饰局部变量，则是存到栈里，可以修改，而c++的话要看情况是否使用内存。
另外c的const是外部链接，c++的const是内部链接（const int a）。const在c中修饰后的变量是常变量（不能被定义数组也不能修改），在c++中是常量。

**⑥局部变量和全局变量和静态变量的区别**
**局部变量（自动变量）：**在函数内部定义，作用域是函数内部，保存在栈中。
**全局变量：**在函数外定义，可以为本文件中其他函数所共用，在全局变量定义后的程序所有的文件的部分都可以用（静态全局变量只能在当前文件中），定义之前的部分可以用extern。
全局变量和局部变量碰上要用局部。他无论有没有被static，本身也是它们在程序开始运行前就分配了固定的字节，静态的保存在全局（静态）存储区（只读数据段）（ROM中）。
**静态变量（static）：**把**局部变量**改变为静态变量之后是改变了它的存储方式和生命期。把全局变量改变为静态变量之后是改变了它的作用域，限制了使用范围。
可以理解为加上静态之后，作用域只在函数内（静局）和本文件内（不包含本程序的其他文件）（静全）。全局变量作用域在整个程序所有文件内。
存储方式都变成了全局（静态）存储区（只读数据段，ROM中）（静全和静局和全局都在这里）。
生命周期都变成了程序结束后os回收（静全和静局和全局都在这里）（静局和局部的区别就是static局部变量只被初始化一次，下一次依据上一次结果值，局部生命周期本函数，结束后重新初始化）。
在c++中，只有生成了对象，执行了构造函数之后，才会static初始化
c中，一开始就会初始化static


**⑤define和inline的区别：**
宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。
总结就是，内联函数是替换的函数（比宏函数格式上好用），和宏一样开销很小，并且比宏安全。他在编译阶段，宏在预处理阶段。
但是inline不能放到循环体，会代码膨胀，也不能将声明和实现分别放到头文件和实现文件中

##### （2）编译（翻译的一种）
①高级语言通过编译变成低级目标语言。可以是汇编语言，把.i文件变成.s汇编代码，再交给汇编语言处理。或者直接将高级语言编译成二进制代码（机器语言）。

②与**解释**程序要区别开。解释程序也是翻译程序的一种，它是边翻译边运行，而且不能生成可独立执行的可执行文件，应用程序不能脱离其解释器，但这种方式比较灵活，可以动态地调整、修改应用程序，典型的解释型的高级语言有BASIC。而编译是指在应用源程序执行之前，就将程序源代码“翻译”成目标代码，因此其目标程序可以脱离其语言环境独立执行，使用比较方便、效率较高。但应用程序一旦需要修改，必须先修改源代码，再重新编译生成新的目标文件(＊.OBJ)才能执行。现在大多数的编程语言都是编译型的，例如Visual C＋＋、Delphi等。

③编译过程。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1686993362348-3fce0d84-8521-43eb-a59c-ad85a3363de6.png#averageHue=%23f8f7f7&clientId=ufa2d4416-cda9-4&from=paste&height=232&id=uda8de741&originHeight=773&originWidth=1198&originalType=binary&ratio=1&rotation=0&showTitle=false&size=188278&status=done&style=none&taskId=u876f0d6b-bed8-498d-becd-362bdf790b1&title=&width=360)![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1686993538647-8ab8af91-2678-4c6c-91e2-d46ab04c1cf2.png#averageHue=%23b8d1eb&clientId=ufa2d4416-cda9-4&from=paste&height=227&id=ua7b29893&originHeight=778&originWidth=1193&originalType=binary&ratio=1&rotation=0&showTitle=false&size=195031&status=done&style=none&taskId=u81af1511-6ca8-4bc0-923b-f3b90c3a448&title=&width=348)

④词法分析：字符流->单词流，从左到右依次将ASCII码转换成TOKEN形式（含有目标字段和类型的结构体）
编译器扫描源文件的字符流，过滤掉字符流中的空格、注释等，并将其划分为一个个 的 token，生成 TOKEN序列。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1686992202400-600b87c7-d61e-419e-9c19-18296044006f.png#averageHue=%23eeeeee&clientId=ufa2d4416-cda9-4&from=paste&height=214&id=u194ae5e6&originHeight=398&originWidth=722&originalType=binary&ratio=1&rotation=0&showTitle=false&size=145025&status=done&style=none&taskId=ua755c14b-d84b-4f82-bad5-39aed319386&title=&width=389)![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1686992907623-ef270cf4-a8dc-4f7d-b72e-0f316feb850a.png#averageHue=%23ededed&clientId=ufa2d4416-cda9-4&from=paste&height=224&id=yIZDZ&originHeight=712&originWidth=977&originalType=binary&ratio=1&rotation=0&showTitle=false&size=192086&status=done&style=none&taskId=u0cb8b1fe-aa9f-4070-84f8-022553bb474&title=&width=308)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1686992682574-38ac929d-3869-4fdb-88a9-80fe1bcaabcb.png#averageHue=%23f7f7f7&clientId=ufa2d4416-cda9-4&from=paste&height=125&id=ucc019195&originHeight=294&originWidth=931&originalType=binary&ratio=1&rotation=0&showTitle=false&size=75005&status=done&style=none&taskId=ucd2bc05c-5fcb-40f8-b118-fa9982aecf5&title=&width=396)![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1686992887592-1deec85d-32a3-4d4a-bd35-e2ab71604216.png#averageHue=%23ededed&clientId=ufa2d4416-cda9-4&from=paste&height=127&id=u797e88c8&originHeight=379&originWidth=896&originalType=binary&ratio=1&rotation=0&showTitle=false&size=129564&status=done&style=none&taskId=ubdcf9d49-6501-4624-a59d-af08649fd7a&title=&width=300)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1686992926055-247cf711-52e9-4600-8e46-4816689cf682.png#averageHue=%23f2f0ef&clientId=ufa2d4416-cda9-4&from=paste&height=153&id=u5c76ef99&originHeight=206&originWidth=944&originalType=binary&ratio=1&rotation=0&showTitle=false&size=39486&status=done&style=none&taskId=u71b4fae9-edab-46aa-9997-5b484d2c010&title=&width=703)
状态:一个标识，能区分自动机在不同时刻的状况。有限状态系统具有任意有限数目的内部“状态”
自动机接受一定的输入，执行一定的动作，产生一定的结果。
自动机的本质:根据状态、输入和规则决定下一个状态
状态 +输入(激励)+规则 -> 状态迁移
垃圾有限状态机一般都是用 switch + while + if 语句实现的
辨别TOKEN是标识符还是关键字，用Trie树的做法因为不管是从空间上还是时间上，Trie树的方式都优哈希表的方式。用switch语句实现。

⑤语法分析
单词流->语法树，同时检查语法错误
收集标识符的属性信息：类型(Type)、种属(Kind)、存储位置、长度、值、作用域、参数和返回值信息
语义检查：变量或过程未经声明就使用、变量或过程名重复声明、运算分量类型不匹配、操作符与操作数之间的类型不匹配。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1686994491202-04876dfe-9be9-4611-983a-7afb06ca8b04.png#averageHue=%23eeeeee&clientId=ufa2d4416-cda9-4&from=paste&height=260&id=u06c1a746&originHeight=553&originWidth=709&originalType=binary&ratio=1&rotation=0&showTitle=false&size=205944&status=done&style=none&taskId=u3dc5fdc9-9f60-45d8-8adf-6c5e1c872b9&title=&width=333)

⑥语义分析和中间代码产生
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1686994738891-27fc8f7a-ddc3-4711-851b-5930cbcf32f4.png#averageHue=%23fbfbf9&clientId=ufa2d4416-cda9-4&from=paste&height=269&id=ud9aeb333&originHeight=514&originWidth=728&originalType=binary&ratio=1&rotation=0&showTitle=false&size=211804&status=done&style=none&taskId=ua62f9918-033b-47ab-bc5a-d4e769ae0c9&title=&width=381)

⑦代码优化和代码生成
一般优化方法有：常量表达式优化、公共子表达式优化、消减运算强度、不变表达式从循环内外提

##### （3）汇编
汇编程序把汇编语言代码转换成.o的二进制代码（机器语言）

##### （4）链接
把多段二进制代码拼接起来，形成可执行程序，再经过装入等步奏运行。静态链接（在运行之前，把目标模块进行链接，需要修改地址），装入时动态链接（装入内存时进行，便于修改和更新，便于共享目标模块），运行时动态链接（执行时未用到的目标模块，不会内存和链接）。

##### （5）装入
①绝对装入
地址都不需要改，按逻辑地址放到物理地址上
②可重定位装入
静态重定位。在模块装入的时候进行地址的唯一一次转换，作业进入内存后就动不了了，也不能扩展
③动态运行时装入
动态重定位。在运行时再把装入内存时的相对地址通过重定位寄存器转换为绝对地址。优点有，可以把程序分配到不连续的区域、运行程序前可以只装入部分代码就能运行、运行期间需动态申请内存、便于程序段的共享

---



#### 2、进程的定义、组成
##### （1）定义
①正在运行的程序的过程的实例，人是程序，人生是进程(意义所在)。
②他是os基本调度单位和最小资源分配单位。
③一个进程可以包含多个程序，一个程序也可以对应多个进程。
④可以并发，可以和其他进程进行通信。
⑤有个task_struct，用来管理进程，每个进程有进程id

##### （2）组成
①PCB（唯一标识符，寄存器，pc值，优先级，内存分布情况）
②代码部分
③数据部分（各种变量常量数据结构）
④资源（网络连接，文件，内存等）

##### （3）线程
①一个进程可以有一个（至少）或多个线程，线程有自己的TCB。
②线程创建简单，共用进程资源空间和优先级。
③线程没有单独的地址空间和资源分配，所以线程之间的通信和资源使用要互斥同步进行。
④进程间通信需要使用操作系统提供的机制，如管道、共享内存等。而线程是进程的一部分，同一进程中的多个线程可以并发执行，它们之间可以直接共享内存，可以通过共享变量等方式进行通信，这就是线程的优势（切换方便，共享方便）。
⑤一个线程的崩溃可能会导致整个进程的崩溃。
⑥同一个进程的多个线程各自拥有自己的栈，这些栈虽然是独立的，但是都位于同一个地址空间中，所以一个线程可以通过地址去访问另一个线程的栈区。
⑦每个线程在内存有独立的task_struct成员。每个线程有线程id
⑧用的线程库是什么。nptl线程库

##### （4）编译后的进程内存区组成（区别进程的组成）
①代码区（只读）
②数据区（存全局变量和静态变量）：分有全局初始化数据区（存储已经初始化的全局变量和静态变量，这些变量在编译时就已经分配了内存并初始化了初始值）和全局未初始化数据区（BBS存储未初始化的全局变量和静态变量。在程序加载时，系统将这部分数据区初始化为0或空值。）
③堆区：手动释放分配（malloc），容易产生碎片
④栈区：自动释放分配（int a），用于管理函数调用、局部变量和函数参数。每个线程有自己独立栈区
⑤常量区（用于存储常量字符串）和动态链接库区（用于存储动态链接库的代码和数据）
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1687167248526-70f62c12-1fa0-4e20-b05a-de6059284d58.png#averageHue=%23f8f5de&clientId=uf5615618-e70f-4&from=paste&height=276&id=u9d793a32&originHeight=595&originWidth=716&originalType=binary&ratio=1&rotation=0&showTitle=false&size=90352&status=done&style=none&taskId=ub8c3c6e4-59e8-4376-ba45-d4c6548c892&title=&width=332)![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1687226529690-ce4c600f-a178-4a7e-9a52-325be870dfb9.png#averageHue=%23fafafa&clientId=ud002ca5d-19a8-4&from=paste&height=273&id=ud691b3f8&originHeight=842&originWidth=1158&originalType=binary&ratio=1&rotation=0&showTitle=false&size=80062&status=done&style=none&taskId=u71314f46-dd11-4e29-ba9d-3ed8e70b638&title=&width=376)

---


#### 3、指针
**（1）什么是指针，什么是指针变量？**
 	指针是一个值为内存地址的变量,可以说它就是一个地址。而指针变量则是用来存放地址(指针)的变量。  。指针定义int *p（int *p = &a），说明p是int*类型的地址。

**（2）和指针相关的两个基本操作是什么？它们分别表示什么含义？**
 取址运算&    解引用运算*  取得变量的存储地址   根据变量的相关地址找到向量   

**（3） 什么是野指针？野指针有什么危害？**
 野指针是乱指的指针，指的地址未明确。危害是读不出相应的值或者破坏别的功能。  

**（4）如何给指针变量赋值？**
 p =&a  p=q（q是已经赋值的指针变量，而不是*p = *q（这是地址指向的值））   int *p   int *p = &a

**（5）引用&和指针的区别和取地址的区别**
①引用就是一个不会更改指向的别名，必须定义时就赋值，之后用它和用原来的内咯给你是一样的。
②引用底层就是一个不知道其的存储地址的指针，大小也是指针大小，查他的地址就是原来的内容的地址
③引用时左值，取地址是右值。
④引用可用来当函数的参数（调用时可以方便改值）和返回值
⑤常引用const int& x 在使用引用x的过程中不会改变x的值

#### 4、read write open fopen read fread fscanf sprintf sscanf
**（1）他们的区别**
①read的最后的一个参数是读入的最大长度，如果源文件过大，后面没有数据，也不会读入。write最后一个参数是写的必须的长度，如果后面没有有效数据，直接补0，照样输出最后一个参数的所有长度。两者都可以对文本文件和二进制文件操作。

②不像fscanf，他没法操作二进制文件，如果写入文件的数据中全是char，则把写入的文件弄成文本文件，可以直接看的。如果写入的数据有非字符，比如int，则写入的文件是二进制文件，不能直接看，但可以通过%！xxd来看，%！xxd -r来还原，虽然不能看，但读出的时候可以以任意数据类型读出，比如结构体等，不需要考虑文件中的可视化内容，根据二进制流进行读出就行，格式很规范。

③以及如何以二进制文件传输并且将其以文本用形式存储到文件里（简单的通过fwrite，fread就可以，fscanf这种只能用文本文件）。

④FILE是文件流，用户态文件缓冲区。fread，fwrite是对用户态有缓冲文件。write和read没有缓冲，更加原始。fopen和open的区别除了fopen通过FILE文件流进行缓冲外，open比fopen能打开的形式更多（比如管道），open也可以声明文件权限。

⑤fread，fwrite与write和read的速度，不一定谁快。如果buf申请的很低的话，前者比后者块。但大多数情况下，前者需要buf先传到用户态的有缓冲文件FILE里，再传到目的地。后者不需要，少一个转化内核态的步骤，所以大多数情况后者快。而且某些特殊情况只能用后者。

⑥sscanf() 从一个字符串中，转化出格式化的数据。
sprintf() 将一个格式化的数据，转化成字符串

**（2）参考文献**
[https://blog.csdn.net/shenwansangz/article/details/50265999](https://blog.csdn.net/shenwansangz/article/details/50265999)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1687164389003-177e1a81-ce29-4632-ae2f-d52912af7f20.png#averageHue=%23edf0f7&clientId=ua56b7a09-1280-4&from=paste&height=253&id=ud20b312a&originHeight=115&originWidth=306&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6449&status=done&style=none&taskId=u70b0550f-6ef9-47d9-8440-e2676a2fc6c&title=&width=672)

**（3）二进制文件和文本文件的区别**
文本文件的优缺点。 fscanf没法来操作二进制文件，只能从文本文件里整。二进制文件跟适合传输，文本文件更适合操作和可视化。 **文本文件必须都是字符串，二进制文件不全是字符串**。

**（4）read磁盘文件和read设备文件（stdin，通过终端键盘输入）的区别**
 后者如果一直不输入的话会造成阻塞。

#### 5、char *p    和  char p[]  的区别   
①前者不在栈，在文件的只读区域，在常量区，只能通过操作只读的函数来，后者在栈里面。
②前者需要主动申请空间，主动释放空间，后者不用。char *p=malloc[1024]    char p[1024]。  
③同样有char *argv[] = {"1","2"} 是指针数组，数组里的每个元素是指针，相当于 char *p，其中每个元素都在常量区。 char (*argv)[]是数组指针，是个指针，指向数组的。  （[]的优先级比*高）

#### 6、sizeof、strlen、length，length（）、size（）（经典面试题）   
**（1）strlen**
strlen是通过指针的移动来计数，直到找到\0（计数到之前），更适合去应用文本文件，文本文件有效数据后是\0，可以直接返回（二进制不行咯，二进制文件哪里都可能有零，并不是可视化的数据）。

**（2）sizeof**
sizeof就单纯是定义后的定义长度（有些容器或者数组会动态分配长度和更新长度），应用二进制文件的话依然很有效。并且！！！！一般数组定义的话其真实大小是有效位+1(最后一位的\0也要算上)。
read recv一般就是sizeof，send write可以是strlen。

**（3）length **
数组的属性，数组元素个数

**（4）length() **String的方法
String的方法，字符串获取字符个数

**（5）size() **String的方法
集合的元素个数。 除了List，Set和Map也有size()方法，size()方法最后要找的其实还是数组的length属性。

除此之外，他们没有任何区别，使用上结果也没区别
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1682342478838-1d474900-0673-4c86-aff3-4373f5133fb6.png#averageHue=%232a2f38&clientId=u3764e6d5-0e67-4&from=paste&height=120&id=u96f1845b&originHeight=85&originWidth=258&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4203&status=done&style=none&taskId=u3babc171-fa24-44df-99dd-22fbe1d70be&title=&width=365)![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1682342460920-2007d36f-6321-448b-a394-f27c74023272.png#averageHue=%230f0e0d&clientId=u3764e6d5-0e67-4&from=paste&height=120&id=u3038f6b5&originHeight=126&originWidth=313&originalType=url&ratio=1&rotation=0&showTitle=false&size=4157&status=done&style=none&taskId=u7ae9d5c9-c190-457e-b573-f9ac8d25b8f&title=&width=298)
#### 
#### 7、进程组、会话、僵尸进程、孤儿进程、守护进程
**（1）进程组**
①由一个或多个进程组成，至少一个进程（不一定有组长）
②组id为组长进程id，组长进程不能改组ID（setpgid），组长死了组依然存在
③子进程默认和父进程一个进程组
④键盘发送信号，所有进程组进程都会受到信号

**（2）会话**
①由一个或多个进程组组成
②创建新会话的进程（setsid）被称为新会话的会话首进程
③会话有个控制终端，有个终端进程（控制进程）和终端沟通，终端进程受到信号会传给会话内的所有进程。
④会话有最多一个前台进程组合多个后台进程组（有控制终端的必须要有前台进程组）

**（3）僵尸进程**
子进程终止，但父进程没有wait

**（4）孤儿进程**
父进程在子进程还没终止前终止

**（5）守护进程**
①所谓守护进程(daemon)，就是在默默运行在后台的进程，也称作“后台服务进程”，通常守护进程的命名会以d结尾。日志进程和ssd之类的都是守护进程
②步骤：父进程创建子进程，然后让父进程终止。 在子进程当中创建新会话。修改当前工作目录为根目录，因为正在使用的目录是不能卸载的。重设文件权限掩码为0，避免创建文件的权限受限。关闭不需要的文件描述符，比如0、1、2

#### 8、信号量、条件变量、互斥锁、PV操作、消息队列（IPC）、共享内存（IPC）、管道、管程（IPC）
**（1）信号量（Semaphore）**
①用于线程进程
②一种计数器，用于控制对一种共享资源（s）的访问。它通常被用来限制同时访问共享资源的线程或进程的数量
③两个源语（wait（s） signal（s）），可记为PV（PV操作常用信号量来操作）

**（2）条件变量（Condition Variable）**
①通常只用于线程
②完成线程的同步通信，用pthread_cond_wait把线程加入到阻塞队列从而锁住，同样有pthread_cond_signal。他们的底层原理是：上半部分是首先需要检查锁的状态，要求是已经上了锁mutx。然后将本线程移入唤醒队列，最后是解锁之前的锁并陷入等待。这三部是原子操作。下半部分是被唤醒之后，根据signal唤醒之后开始加锁，并继续程序的运行（之前是直接暂停咯，和while的不同之处）
③与信号量的区别：只面向线程。信号量是针对资源的个数进行，条件变量是针对阻塞线程本身来进行。

**（3）互斥锁（Mutex）**
①用于线程或进程
②互斥锁用于保护共享资源，确保在任何给定时间只有一个线程可以访问该资源。

**（4）消息队列（Message）**
①不同进程间通信
②直接通信方式和间接通信方式，后者需要使用信箱。他们把想要发送的消息挂到别人的消息队列缓冲
③最广泛，微内核常用

**（5）共享内存（Shared Memory and mmap）**
①进程间通信，通信的进程之间存在一块可以共同访问的共享空间，他是一块映射到进程地址空间的内存。
②分为低级方式（数据结构共享**MMAP**）和高级方式（内存空间共享**Shared Memory **）
前者在实际硬盘中，大但慢。后者在内存中，快但小。
③因为是间接共享内存需要用PV来操作，用系统调用实现（同一进程的线程不需要，他们直接共享）
④可以理解为一个公共大布袋，进程之间的数据交换通过它，而不用再涉及内核
⑤共享内存是最快的进程间通信方式，缺点是只能在单主机上使用

**（6）管道（pipe）**
①常用语父子进程之间通信，一种共享文件，用write和read
②内存中有缓冲区
③先进先出，半双工通信（用两个管道实现全双工）

**（7）管程（Monitor）**
①用于线程间的同步互斥，其中包含了很多东西，相当于把各个功能封装
②管程提供了一种结构化的方式来管理共享资源的访问，同时封装了互斥锁、条件变量和共享数据等。
③由四部分组成：管程名、局部于管程内部的共享数据结构说明、对于该数据结构的操作的一组过程、对局部于管程内部的共享数据设置初始值的语句。

#### 9、磁盘高速缓存（disk cache）、缓存（cache）和缓冲（buf）的区别
**（1）缓存（cache）**
①缓存（cache）介于cpu和内存之间，用来缓解cpu和内存之间的速度差异
②常用SRAM，分为一级二级

**（2）磁盘高速缓存（disk cache）**
①介于内存和磁盘之间，用来提高I/O速度
②逻辑上属于磁盘，物理上是内存的一部分。
③高速缓存上有的，低速设备一定有。高速设备先访问高速缓存，没有再访问低速设备并复制到高速缓存。

**（3）缓冲（buf）**
①缓解cpu和I/O速度不匹配的矛盾，提高并行
②类别：单缓冲、双缓冲、缓冲池、循环缓冲
③低速设备传给缓冲区（低速设备不一定备份），高速设备不会访问低速设备，只会访问缓冲区。

#### 10、指针常量、常量指针、指针数组（函数）、数组（函数）指针
**（1）常量的指针**
①（const int *） p  = &num  或者 （int const * ）p  
②不能修改指针所指变量的值   *p=100
③可以改指针所指的变量p=&num1

**（2）指针是常量**
①int *（ const p） = &num时  
②可以改指针所指变量的值   *p=100
③不可以改指针所指的变量p=&num1
加括号方便辨别，实则不用加。下面两种不同
**（3）常量指针常量**
const int *const p = &num 两个都不可以修改

**（4）函数（数组）的指针**
① int (*p)[] 、 int (*p)（int a）
②看括号是最先结合的内容，也就是p是指针
③函数的返回类型是int

**（5）指针的函数（数组）**
① int *p[]、int *p（int a）
②先结合的数组（函数），最后有个指针，说明是指针的函数（数组）
③函数的返回类型是int*

#### 11、malloc的底层实现是怎样的？free是怎么回收内存的？malloc和new的区别是什么(面试常考)
**（1）malloc的底层实现**
①分为内存池管理和内存分配
②内存池管理：内存池是一个预分配的连续内存块，在内存池从中找到一块合适的空闲内存块，没有的话系调
③内存分配：找到合适的内存块后，分配一个内存头块，记录内存大小和其他信息，并把内存的地址返回给调用者

**（2）free的底层原理**
①分为内存池管理和内存回收
②内存回收：接收malloc分配的内存头部指针，读取信息后把其标记为空闲内存块
③内存池管理：相当于碎片合并和大内存划分工作

**（3）malloc和new的区别**
①c++new/delete   c malloc/free    不能混用
②malloc/free 时标准**库函数**，new/delete是c++的**表达式/操作符**
③malloc在开辟空间时不能初始化空间，new表达式可以初始化空间
④malloc函数的参数传递是开辟空间的大小，new不需要改变空间的大小
⑤malloc返回时void*    new返回值是相应的指针
⑥new/d申请数组和回收数组时都要加上[]
⑦new申请内存空间的时候
可以采用   int * p2 = new int[10]()  // 一开始就将所有数组元素赋值为0
也可以采用int * p2 = new int[10]   //空间的数据值不确定，可能有脏数据

#### 12、区分以下概念：内存泄漏、内存溢出、内存踩踏、野指针？
（1）**内存泄漏**是 之前申请的内存空间没有及时的回收，导致这部分的内存过多，导致程序崩溃
（2）**内存溢出**是 申请的空间超过系统或进程能提供的最大内存空间
（3）**内存践踏**是 使用的内存超过了申请的内存的边界，操作了不该操作的内存
（4）**野指针**是 指针指的地方不正确，是不可知的地址，有很多可能造成野指针，比如未初始化，指向的内存已回收,relloc的滥用，释放指针后未置空等。可以改用引用的形式避免

#### 13、函数重载、重写、隐藏
**（1）重载**
①c++独有，c没有
②本质是名字改编name mangling
③根据参数，类型，顺序，参数来改。 返回值不能充当依据
④只能在同一个类中定义（父子类都不行）
⑤重载功能与函数成员是否是虚函数无关。其实可以理解成虚函数（virtual）只在不同范围内（如父类和子类）起作用。在上述程序中，函数都处于一个类，判断两个函数的关系可以不用看是否是虚函数

**（2）重写（重定义、覆盖）**
①父类（基类）中定义，子类（派生类）中重写方法，父类（基类）用虚函数 virtual （子类也是）
②参数，类型，顺序，参数，返回值必须一致，只是函数内方法不同
③**不能是private**，静态static不能修改成非静态，构造函数不能重写
④往限制域高的地方修改

**（3）隐藏**
①也是在父子类之间（基类派生类）
② 如果派生类的函数与基类的**函数同名，参数不同。**此时，不论**有无virtual**关键字，基类的函数将被隐藏
③如果派生类的函数与基类的**函数同名，参数相同**，但基类函数**没有virtual**关键字时，基类的函数被隐藏
④对比于重写，重写是必须虚函数，而且除了函数内部所有东西都相同。

#### 14、深拷贝和浅拷贝（复制构造函数）
**（1）浅拷贝**
 将原对象或原数组的引用直接赋给新对象，新数组，新对象／数组只是原对象的一个**引用**
**（2）深拷贝**
 创建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是“引用”

#### 15、多态的分类、虚函数、虚表、纯虚函数、抽象类、虚拟继承、内存空间布局
**（1）多态的分类**
①静态多态（静态联编）：在**编译**的时候，函数**重载**，运算符重载、函数模板
②动态多态（动态联编）：在**运行**的时候，利用虚函数，指同一个消息，通过不同的对象表现出不同的行为，**重写**后运行也就是子类重写虚函数后，用父类的指针指向子类对象 或者 用父类的引用引用子类对象 ，从而实现了多态
③引用访问虚函数表现动态多态，成员函数访问虚函数表现动态多态，执行回调函数也体现多态
④通过构造函数和析构函数访问虚函数表现静态多态，通过对象名访问虚函数，表现静态多态

**（2）虚函数，虚表**
①定义虚函数后就在类的存储空间上面加一个指针vfptr，他指向虚表（存储各个虚函数的入口地址，二连指）
②定义虚函数就在函数前面加上virtual
③如果是派生类有新的虚函数，需要在虚表中基类的虚函数下面加上新的虚函数地址
④构造函数，static，inline不能是虚函数
⑤析构函数可以是虚函数（甚至是纯虚函数），有些情况 （比如**基类有虚函数**）时，一般都将虚构函数设为虚函数
用来解决内存泄漏的问题，析构函数具有唯一性，派生类释放时会主动使用基类细狗函数，导致派生类的细狗没用
⑥虚函数的究极意义：**当基类的某个成员方法，在大多数情形下都应该由子类提供个性化实现，但基类也可以提供一个备选方案的时候，请将其设计为虚函数**
⑦一般情况下，**不允许在构造函数或者析构函数中调用虚函数**。其实语法上都没有问题，只是会**失去多态性**。如果在构造函数中调用虚函数，会先调用父类中的实现，也就失去了多态的性质。析构函数也一样
⑧构造函数能否有虚函数，不行，虚函数表在构造函数实现后实现，构造函数生成整个变量。所以前后顺序不能变

**（3）纯虚函数，抽象类**
①抽象类不能实例化（只用来继承），只能当有派生类中没有纯虚函数的时候才能将派生类实例化
②定义了纯虚函数的类，或定义了protected型构造函数的类，是抽象类
③纯虚函数的究极意义：**当基类的某个成员方法，必须由子类提供个性化实现的时候，请将其设计为纯虚函数**

**（4）虚拟继承**
①虚拟继承为了解决多重继承问题，需要使得多重继承（菱形继承）的基类在只存储一份
②虚拟继承时内存空间布局完全不同，基类在下面，派生类在上面，基类虚表在他们中间，新增虚基表在最上面，新增派生类虚表（与基类的虚表分开了）在虚基表下面
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1687752602040-7a58c804-a5c8-4819-8edb-5212ea4d6e31.png#averageHue=%23bb8b49&clientId=u07688f66-b3de-4&from=paste&height=202&id=ue6ad54f0&originHeight=653&originWidth=1188&originalType=binary&ratio=1&rotation=0&showTitle=false&size=218695&status=done&style=none&taskId=u2d78cca9-18a4-4625-b2ee-67a7bfff7b7&title=&width=368)![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1687752663512-463077fe-f635-4660-9401-0c1981bb3b2d.png#averageHue=%23f7f2ea&clientId=u07688f66-b3de-4&from=paste&height=189&id=ubf78b5bc&originHeight=718&originWidth=1183&originalType=binary&ratio=1&rotation=0&showTitle=false&size=188274&status=done&style=none&taskId=u055cc5cb-b647-4149-9d8f-fc96957ba53&title=&width=312)

#### 17、继承和封装
**（1）通常访问权限**
①类内部：可以访问public成员，protected成员，private成员
②类外部：只能访问public成员

**（2）继承的分类**
①公有继承，派生类的新增成员（相当于类内访问）可以访问基类**public成员，protected成员**。派生类的对象（相当于类外访问）只能访问**派生类和基类继承的public成员。**
②保护继承，派生类的新增成员（相当于类内访问）可以访问基类**public成员，protected成员**（pubilc和pro成员变成protected成员）。派生类的对象（相当于类外访问）只能访问**派生类的public成员**
③私有继承，派生类的新增成员（相当于类内访问）可以访问**基类public成员，protected成员**（public和pro成员变成private成员）。派生类的对象（相当于类外访问）只能访问派生类的public成员
④私有继承和保护继承的区别就是。保护继承不管继承层次有多少层，在派生类内都能够访问基类非私有成员；若在继承层次中，出现了私有继承，从该层开始，就不能在派生类内层次中访问基类的非私有成员。因为私有继承把他们变成了private成员
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1687763152643-b2de4727-625d-4db0-be7f-ab260c9e0a88.png#averageHue=%23f2f2f1&clientId=u07688f66-b3de-4&from=paste&id=ucdfdd94e&originHeight=182&originWidth=566&originalType=url&ratio=1&rotation=0&showTitle=false&size=11976&status=done&style=none&taskId=u0e1d04d1-858b-4fa4-90f5-91c930142ad&title=)

**（3）继承的方式**
①实现继承
②接口继承

**（4）封装**
①把数据和代码放在一起，防止被干扰
②把客观事物封装成抽象的类，并且类可以把⾃⼰的数据和⽅法只让可信的类或者对象操作，对不可信的进⾏信息隐藏，将公共的数据或⽅法使⽤public修饰，⽽不希望被访问的数据或⽅法采⽤private修饰。

#### 18、运算符重载
**（1）本质是函数调用**
①可以是和调⽤运算符的⽅式调⽤，data1+data2
②也可以是调⽤函数的⽅式，operator+(data1, data2)
③重载的类型必须是一个类类型或者枚举类型。

**（2）规则和不可以重载的类型**
①带点（.）的四个和sizeof不能重载
②不能改变参数的个数、参数的顺序，不能设置默认值，不能改变运算符的优先级

**（3）++i和i++**
①前者返回的是引用，后者返回的是对象
②后者需要新建一个对象，前者不用，所以前者快
③前者是左值，后者是右值（左值能放左边和右边，右值不能放左边，左值能取地址，右值不能取地址）
④两者在for里面是一样的

**（4）方式**
①普通函数
②成员函数（推荐）
③友元函数（多用来处理双目运算符）

**（5）复杂的运算符重载**
①函数调用运算符
②隐式转换operator 目标类型() {   return  目标类型的变量；}，达到Point  pt = 10;效果
如果不想隐式转换，在构造函数前加上explicit

#### 19、pimpl设计模式和singleton单例模式（重点）
**（1）pimpl设计模式**可以理解为指向实现对象的指针
①基于嵌套类，他首先在类中前向声明另一个类，再在实现文件将其类声明出来，再写出方法
②实现了信息的隐藏，只要将头文件和动态库交给第三方库使用，实现文件随时自己升级给他
③实现了平滑升级和编译防火墙



 Widget 的三个数据成员放在一个实现结构体 Impl 里面，然后在头文件中，仅仅对 Impl 进行了声明；在源文件中是具体的实现。在这种情况下，如果 Widget 和其相关的类的代码有变动的话，只需要重新编译变动的代码即可，其他引用了 widget 头文件的用户代码不需要重新编译，只需要在链接阶段重新链接即可。这样也可以加快编译速度，因为用户代码不需要编译 Widget 相关类的代码（比如 LineDrawer）。这就是 Pimpl 的主要思想。

**（2）singleton单例模式（23种设计模式中的一种）**
①要求：一个类只能生成一个对像，而且是唯一的对象
②步骤：
构造函数私有化-不能在类之外创建对象
定义了一个静态成员函数（public中）
其在类内部、可以调用构造函数、建议是堆对象、只有第一次调用该函数时才执行new
之后的调用都是直接返回第一次new出来的对象
考虑对象复制的情况还要禁止复制  将拷贝函数和赋值运算函数私有化（或从类中删除 = 0）
③应用场景：C语言所有的全局变量都能被代替
④代码

```c
class Singleton
{
private:
	Singleton(int ix = 0, int iy = 0)
	: _ix(ix)
	, _iy(iy)
	{  cout << "Singlenton(int, int)" << endl}

	//禁止复制的操作：
	//将拷贝构造函数和赋值运算符函数私有化
	Singleton(const Singleton &);
	Singleton & operator = (const Singleton&);

		// //禁止复制的操作1：将拷贝构造函数和赋值运算符函数也私有化
		// Point(const Point &) ;
		// Point & operator=(const Point);
    	//操作2：
		// //C++11禁止复制的操作
		// //=delete表示该函数从类中被删除了
		// Point(const Point&) = delete;
		// Point & operator=(const Point&) = delete;

public:
	//返回值是对象，当执行多个return语句时，会调用
	//拷贝构造函数，对象是多个，因此不行
	static Singleton * getInstance()   ////也可以将指针换成引用（&换*），返回值及调用时作相应修改
	{
    	if(_pInstance == nullptr)) {//仅在第一次调用的时候new，其他时候直接返回，保证只创建一个对象
        	_pInstance = new Singleton();  //在堆空间创建
		//不能在栈区直接创建，因为不能返回栈空间的值
        //因为构建函数在私有空间，所以只能用堆咯
		}
        return _pInstance; //* _pInstance 是引用的写法
	}

	static void destory()
	{
    	if (_pInstance) {
        	delete _pInstance;
        	_pInstance = nullptr;
		}
	}


	void printf() const 
	{
        cout << "(" << _ix
             << "," << _iy
        	 << ")" <<endl;
	}

private:
	int _ix;
	int _iy;

	static Singleton * _pInstance;//使用静态数据成员记录被创建的对象地址
};


Singleton * Singleton::_pInstance = nullptr; //静态成员在类外进行初始化

int main(){
	Singleton * p1 = Singleton::getInstance(); //一开始是引用的话改成&p1
	p1->printf(); 

	
	Singleton * p2 = Singleton::getInstance(); 
	p2->printf(); 
	//俩一样，同一个

	//delete p1;//可以但不优雅
	Singleton::destory();

	//调用构造函数出错
	Singleton s = *p1//error
}

//总结
a.定义一个静态成员函数在public，负责生成获取实例
b.定义一个静态成员变量在private，指向这个类的唯一实例
c.将构造函数私有化，复制构造函数和赋值构造函数都私有化或者销毁（= delete）
//饿汉式和懒汉式区分
```

**（3）singleton单例模式饿汉式和懒汉式**
①饿汉模式是Singleton * Singleton::_pInstance = new Singleton(); 这样初始化
②懒汉模式是Singleton * Singleton::_pInstance = nullptr;这样初始化
③饿汉模式线程安全，但每次都要开辟堆空间（实例化）（默认没有回收）
④懒汉模式线程不安全，但只有Singleton * p1 = Singleton::getInstance();才开辟空间（实例化）
⑤懒汉模式效率高，如果没有getlenstance就是“延时加载”

优缺点：饿汉式是线程安全的,在类创建的同时就已经创建好一个静态的对象供系统使用,以后不在改变。
懒汉式如果在创建实例对象时不加上synchronized则会导致对对象的访问不是线程安全的。

从实现方式来讲他们最大的区别就是懒汉式是延时加载,他是在需要的时候才创建对象
而饿汉式在虚拟机启动的时候就会创建，饿汉式无需关注多线程问题
写法简单明了，能用则用。真正用到的时候才去建这个单例对象，“饿汉式”是在不管用不用得上，一开始就建立这个单例对象。

**（4）singleton单例模式三种自动释放模式（亮点）**
①单例模式的对象不像其他类的对象，生命周期很短，可以直接自动释放
①嵌套类autorelease + 静态对象
嵌套类里的类析构函数，会把单例模式的对象也释放了（嵌套类可以访问大类的静态成员）
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688435921811-678ed7cc-33a6-472b-ad18-2bbdf113828c.png#averageHue=%23f3f3f2&clientId=u9fc2cd8f-e9b7-4&from=paste&height=464&id=u05aba7ed&originHeight=580&originWidth=1110&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=221019&status=done&style=none&taskId=u3b93d976-3d7e-4476-a0b6-f640a14ffe1&title=&width=888)
②atexit + destroy+饿汉模式
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688435890750-e2069697-6924-4b6e-b59b-c2a4507fdd05.png#averageHue=%23f4f4f4&clientId=u9fc2cd8f-e9b7-4&from=paste&height=291&id=u12aac159&originHeight=364&originWidth=1130&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=120396&status=done&style=none&taskId=uce784352-acfb-4126-b9bf-4472d47f5f0&title=&width=904)
③pthread_once + destroy
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688435901214-759d835b-2af8-4ea2-acf3-a4c0b1cd3402.png#averageHue=%23f2f2f2&clientId=u9fc2cd8f-e9b7-4&from=paste&height=369&id=u7e3ec639&originHeight=461&originWidth=1122&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=182673&status=done&style=none&taskId=u19666caf-8f73-4fb3-85aa-290e4f34657&title=&width=897.6)

#### 20、string字符串的底层实现（难点可讲）（经常被问）
**（1）Eager Copy(深拷贝) **
①区别于浅拷贝（新引用一个）
②每次赋值（复制）会复制一整份新的，string指针指新的，不修改只翻新

**（2）Copy-On-Write(写时复制) -->单核时代用的很多**
①新增一个引用计数，每次赋值（复制）后就直接计数+1，string指针指过去，不深拷贝
②写操作（修改时），进行深拷贝，不修改只复制时不深拷贝
③读操作，访问下标时，也需要进行深拷贝，不访问下标不深拷贝

**（3）Short-String-Optimatization(短字符串优化) sso-->多核时代**拷贝时栈快，堆慢
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1687788368049-307d240a-e59d-4316-bc40-473c6ad846e0.png#averageHue=%23fcf8f8&clientId=u07688f66-b3de-4&from=paste&height=412&id=u98054198&originHeight=614&originWidth=972&originalType=binary&ratio=1&rotation=0&showTitle=false&size=160187&status=done&style=none&taskId=uc382ae5a-b7f0-488c-b49e-780f997ee04&title=&width=653)
之前无论是构造还是拷贝，都是重新在堆上(使用new关键字)分配一块内存
但sso出来之后小于15字节就在栈上进行操作，比堆快

#### 21、移动语义

[一文入魂：妈妈再也不担心我不懂C++移动语义了 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/455848360)

**（1）意义**
①在程序执行的过程中，会产生大量的临时对象，临时对象起到过渡的作用，操作完之后就马上被销毁 
②所以用移动语义将临时对象进行**直接的转移**，而不是赋值和拷贝

**（2）右值引用**
①const String &a = xxx（const万能引用），这种引用无法分辨xxx是左值还是右值，但他只能绑定左值
②c++11出现了右值引用 String &&a =1或String("hello")，他只能绑定右值，大家也默认知道他绑右值
③一般都用const String &a = xxx来初始化字符串，而不是不加const。因为String &a = xxx后，a也是不能更改的，导致以后想改的话会出问题。所以每次就都加上const来用。但有了右值引用 后不需要加const

**（3）移动构造函数和移动赋值运算符函数**
①诞生于有右值引用时，类中需要加上这俩
②移动赋值运算符函数和赋值运算符函数都有bug，如果左右操作数（指针）是同一个对象的话左会被释放掉
都是通过四部曲解决。移动赋值运算符函数（自移动、回收左操作数申请的空间、移动操作、返回指针）
赋值运算符函数（自复制、回收左操作数申请的空间、深拷贝、返回指针）
③有移动语义的函数的优先级要优于复制控制语义的函数的执行（编译器不会自动提供）
④为当类中存在虚析构函数时，编译器不会自动生成移动构造函数和移动赋值运算符。

**（4）std::move**
①把左值强制转换成右值方便使用，本质就是做了一个强制转换：static_cast<T &&>(lvaue);
②他的生命周期还在，只是被转移走了内容。转移的时候伴随着使用（右值引用或者其他使用右值）
③之后必须重新给他赋值才能用
④没有移动的含义

#### 22、智能指针
**（1）RAII技术**
①利用**栈对象的**生命周期来管资源，对象生命周期结束会自动调用细狗函数，不允许拷贝和赋值，提访问资源方法
②用**类模板**实现，将其他类型的堆对象的指针交给RAII的对象，就能自动回收
③简单的智能指针

**（2）智能指针**
①基本原理：一个**类模板**，里面重载了*和->用来指向想要智能管理的类的对象的堆空间并且类模板里面有个指针成员。程序结束时，指针成员被销毁，他们会自动调用析构函数来释放所指向的空间资源，从而实现自动释放动态申请的空间
②而且必须要修改拷贝构造函数和赋值构造函数。因为如果没有，只能使用原生的拷贝构造函数和赋值构造函数，两个智能指针指向一个地方时，他们分别销毁并调用析构函数会报错，因为只有一个资源两次释放

**（3）auto_ptr**
①指针原对象拷贝给指针新对象的时候，原对象就会被设置为nullptr
②缺点就是，如果指针原对象再次使用的话就会崩溃
③c++17禁用了

**（4）unique_ptr**
①它直接将拷贝构造函数和赋值重载函数给禁用掉
②继承一个nocopy类

**（5）share_ptr**
①可以复制和赋值，引用计数器（use_count）加1，销毁一个指针减1，计数器为0释放资源
②强引用
③相互引⽤时的死锁问题
④enable_share_from_this  不让他返回的时候+1

**（6）weak_ptr**
①弱引⽤
②是⼀种不控制对象⽣命周期的智能指针，它指向⼀个 shared_ptr 管理的对象。进⾏该对象的内存管理的是那个强引⽤的 shared_ptr，配合 shared_ptr ⽽引⼊的⼀种智能指针来协助 shared_ptr ⼯作，它只可以从⼀个 shared_ptr 或另⼀个 weak_ptr 对象构造，它的构造和析构不会引起引⽤记数的增加或减少
③解决**shared_ptr 相互引⽤**时的死锁问题
如果说两个 shared_ptr 相互引⽤，那么这两个指针的引⽤计数永远不可能下降为0，也就是资源永远不会释放。它是对对象的⼀种弱引⽤，不会增加对象的引⽤计数，和 shared_ptr之间可以相互转化，shared_ptr 可以直接赋值给它

**（7）删除器和智能指针误用**
①unique_ptr的模板参数与shared_ptr的构造函数中有删除器。删除器解决的是：指针所指的空间不是堆 
空间的问题，因为默认删除器是执行的delete操作。
②误用：使用了不同的智能指针托管同一块空间（同一个裸指针）。

#### 23、设计模式
##### （1）分类
分为简单工厂（静态工厂方法模式）、工厂方法和抽象工厂，后两个是重点

##### （2）简单工厂：
有个专门的工厂类来负责生产对象（也就是创建对象），他创建各种各样的对象，不同类的对象都归着一个工厂类来生成。对象的功能和使用不在工厂类，只有创建的时候再工厂内。一级创建模式。
优点有：客户端比较省事，不需要知道具体实现，对象的创建全由工厂说的算，增加新类时，客户端也不用改，实现了对象创建和使用的分离。
缺点有：因为是静态工厂模式，无法新增继承之类的，灵活性很低，而且每次增加对象的时候，还要修改工厂代码。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688183512905-0319e0da-4a4a-4f25-95c8-7529504bf5c1.png#averageHue=%23fbfafa&clientId=u0cde28ff-20bb-4&from=paste&height=386&id=u8a96bfc2&originHeight=482&originWidth=1165&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=107283&status=done&style=none&taskId=u4bc77e0d-55c6-4762-9d0f-cbc41a4268e&title=&width=932)
##### （3）工厂方法：
工厂方法通过采取虚函数的方法，实现了使用者和具体类型之间的解耦，使得变化的对象类型能够方便改变。也就是把原来的大工厂，啥都生产的工厂，变成一个个小工厂，每个小工厂生产一个独有的产品类，工厂基类为抽象类，派生类再实例化。
优点有：静态工厂的优点，但更加灵活，方便增加类，最重要的是一种解耦模式，满足迪米特法则（最少知识法则）、依赖倒置原则和里氏替换原则。而且解决了静态工厂的缺点-开闭法则
缺点有：类的个数会很多、更抽象、接口传参类型需要一致，最重要的是抽象产品只能生成一种产品（抽象工厂解决）
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688183526182-b1602df5-530d-4578-88cb-edbc2eb30190.png#averageHue=%23fcfbfa&clientId=u0cde28ff-20bb-4&from=paste&height=355&id=u8b6b8c32&originHeight=444&originWidth=1165&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=97545&status=done&style=none&taskId=ueffe59f1-47c9-4129-b499-73ce253bf1a&title=&width=932)
##### （4）抽象工厂：每个工厂都能生产所有产品
同一个产品中也有可能有多个不同的小种类，这些小种类很可能和其他产品类也有，这时候如果把这些同一个产品的不同小种类都写成各自的类的话，类就太多了。所以抽象工厂就从之前的和产品单线合作变成了多线合作，多维度。
优点：新增具体工厂很方便，符合开闭原则。客户端能用到独有的类
缺点：新增等级结构比较复杂
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688183543735-efe9a533-a96a-4bc1-bf4a-f38dfd96e6cf.png#averageHue=%23fbfaf9&clientId=u0cde28ff-20bb-4&from=paste&height=502&id=ube24ac93&originHeight=627&originWidth=1131&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=180089&status=done&style=none&taskId=u0a72c4de-2d14-4850-ae21-25b15e99a1a&title=&width=904.8)

##### （5）观察者模式
发布-订阅模式。一种一对多的依赖关系，能添加关注者和取关关注者，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。当一个对象发生了变化，关注它的对象就会得到通知
优点：观察者和被观察者是抽象耦合的，并且建立一套触发机制
缺点：观察者很多时会很慢，一个观察者中出现了循环关系，会导致系统的崩溃，观察者只能知道发生了变化，不知道发生什么变化
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688183615400-b2b4ab34-6cb0-449b-a7c7-3a26f6c9950b.png#averageHue=%23fbf9f8&clientId=u0cde28ff-20bb-4&from=paste&height=477&id=uf36eaae7&originHeight=596&originWidth=1202&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=217409&status=done&style=none&taskId=uc136ec5f-0d4c-40b0-bc52-b43be787322&title=&width=961.6)

#### 24、类与类之间的关联
##### （1）继承和泛化
泛化应该是从下向上的抽象的过程，而继承应该是有上到下的过程。基类是派生类的一部分，用is来理解
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688184409828-4058fc6c-13a3-4db3-86f5-d2e34b303acd.png#averageHue=%23f6f6f6&clientId=u0cde28ff-20bb-4&from=paste&height=569&id=u15890832&originHeight=711&originWidth=1141&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=118106&status=done&style=none&taskId=u13bf878e-b913-470a-aa0d-2ef1cc7a0c3&title=&width=912.8)

##### （2）关联（双向）
彼此知道对方的存在，但不负责对方的生命周期，也就是对方销毁跟我无关，我不用做任何操作。
关联（单向）。一边知道另一边的存在且不负责他的生命周期，但另一边不知道。比如条件变量和互斥锁。
A类**依赖**于B对象，**并且A把B当成一个成员变量**，则A和B存在**关联**关系。 有一对一，一对多，多对多，多对一关系。在代码层面上使用的是指针或者引用，用has关系来理解。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688184421051-3eeb0373-3e4d-4715-a3fd-2d15c7b5a8be.png#averageHue=%23f8f8f7&clientId=u0cde28ff-20bb-4&from=paste&height=532&id=u7187ddf2&originHeight=665&originWidth=1155&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=206096&status=done&style=none&taskId=u71629eea-4030-4459-82ab-faf7a83b4c7&title=&width=924)

##### （3）聚合
是**关联的一种特例**，同样双方都是独立的，整体部分不负责部分部分的销毁但是关联关系在同一层次上，聚合关系在不平等的层次上，一个是整体，一个是部分。
用has-a来理解，用指针或者引用。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688184435288-c41bc4fc-42ff-4083-8a8c-98c6a23fb735.png#averageHue=%23f7f7f7&clientId=u0cde28ff-20bb-4&from=paste&height=524&id=u0173508e&originHeight=655&originWidth=1062&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=80375&status=done&style=none&taskId=uaef425ba-679c-4905-837f-825d70862c6&title=&width=849.6)
##### （4）依赖
一个A类依赖于B类的定义,如果A对象离开B对象,A对象就不能正常编译,则A对象依赖于B对象(A类中使用到了B），对表现在代码层面，类B作为参数被类A在某个method方法中使用。是偶然的，临时的，并非固定的。有以下几种形式：
a.可以将B作为A的成员函数的参数
b.将B作为A的成员函数的局部变量或者返回类型
c.可以使用A调用B的静态方法
用use理解，主要在函数之间
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688184448541-59596985-2c6b-46a5-9782-b2af7220b070.png#averageHue=%23fbf9f8&clientId=u0cde28ff-20bb-4&from=paste&height=214&id=u1678b7d8&originHeight=267&originWidth=984&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=31785&status=done&style=none&taskId=u202cf79b-d380-48b8-8264-545123af4f1&title=&width=787.2)

**（5）组合**
**关联的一种特例，这种关系比聚合更强，也称强聚合。**
整体和个体不独立，在同一模块中同时管理，生命周期必须相同，整体也会负责局部对象的销毁。
用contain-a理解，用子对象的形式。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688184459968-6d76dce1-0a5d-4ad3-8155-e884e0a401ea.png#averageHue=%23fbfaf9&clientId=u0cde28ff-20bb-4&from=paste&height=445&id=ud32fd72a&originHeight=556&originWidth=1025&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=72886&status=done&style=none&taskId=ub5c17fa4-3b17-4ffb-800f-2764f67471d&title=&width=820)
##### （6）耦合度
依赖 < 关联 < 聚合 < 组合 < 继承
继承体现的是垂直的关系，其他四种是横向的关系，其中只有关联式平等关系。

#### 25、面向对象设计原则 低耦合高内聚
##### （1）单一职责原则
一个类尽量只做一件事，只有一个引起他变化的原因

##### （2）开闭原则（重要）
对扩展开放，对修改关闭，面向抽象编程（把基类写入纯虚函数，将其变成抽象类）
之后在下面写派生类，把纯虚函数给重新定义。

##### （3）里氏替换原则（重要）
派生类能够替换其基类。有三种表现形式：
a.子类可以实现父类的抽象方法，表现多态
b.子类可以有自己的个性
c.重点来了，**不能覆盖父类的非抽象方法**（不能c++**隐藏**）
（分清楚重载、重写、隐藏）

##### （4）接口分离原则
使用多个小的专门接口，不用一个大的总接口。也就是把胖接口分离

##### （5）依赖倒置原则（重要）
面向接口抽象类编程。依赖于抽象（因为抽象是稳定的，具体是变化的）。也就是把那些功能都包装成一个整体纯虚函数。
ps：在大多数情况下，开闭原则、里氏代换原则和依赖倒置原则会同时出现，**开闭原则是目标**，**里氏代换原则是基础**，**依赖倒置原则是手段**

##### （6）最少知识原则（迪米特法则）
降低两个或者多个模块之间的耦合程度

##### （7）组合复用原则
**尽量使用组合、依赖的关系**，而不要使用继承。尽量的降低类与类之间，或者模块与模块之间的耦合程度。
#### 
#### 26、MySQL和Redis
写本子上了

#### 27、Nginx和workflow（拓展）


#### 28、STL（STL 具有⾼可᯿⽤性，⾼性能，⾼移植性，跨平台的优点）
##### （1）总体介绍六大组件 
**①容器：**用来存储数据的。也就是数据结构。 （从实现⻆度来看，STL容器是⼀种class template）
序列式容器** vector**（动态arry）、list（双链表）、deque（双队列）、array（静态）、forward_list（单链表）
有序关联式容器 set（集合）、map（映射） 、multiset（可重复key）、multimap。序列式还有string（如v）
无序关联式容器** unordered_map（**常用）、unordered_set、unordered_multiset、unordered_multimap
**②迭代器**：看成是广义的**指针**，泛型的指针。可以访问容器中的元素。 
**③算法**：将元素进行某种操作（排序，取最值）。可以使用迭代器访问容器中的元素。 
**④适配器**：起到适配操作的，⼀种⽤来修饰容器或者仿函数或迭代器接⼝的东⻄。。
容器适配器 stack （默认底层deque）、queue（默认底层deque）、priority queue（默认底层vector）
迭代器适配器（迭代器适配器可以在不改变原有迭代器的基础上，改变迭代的方向、元素类型或其他行为）  
函数适配器   bind、function、mem_fn
**⑤函数对象（仿函数）**：定制化的操作。 
**⑥空间配置器**：空间的申请与释放都是需要空间配置器去操作。（用法 + 原理 + 源码） 
程序 = 容器（数据结构） + 算法
⑦关系：容器通过空间配置器生成，容器生成迭代器，算法通过迭代器使用容器里的元素，仿函数可以协助算法完成不同的策略的变化，适配器可以将容器或仿函数重新包装或修改，以适应特定的需求或使用方式

##### （2）vector
①序列式容器，动态数组，底层是array，会不断扩容，单向扩充，在内存中连续存储元素
②支持下标访问，支持迭代器，支持size()，支持尾插尾删法push_back，可通过函数进行任意删插入（erase，insert）（list支持，deque不支持）。**不支持头插头删法**（deque，list都支持）
③**底层实现：**整个vector就三个指针的大小（24），三个指针在栈区，分别指向数组中的第一个元素、数组中的最后一个元素的下一个位置（size）、当前数组中能容纳的空间的最后一个位置的下一个位置（capacity）。
**push_back扩容：**他们等着数组元素有没有到capacity的大小，到的话就将源空间所有的元素拷贝到新空间，释放原来的空间爱你在新空间中新添加一个元素，空间是物理连续的。具体大小为2*capacity或1.5*capacity。
**insert扩容：**数量小于size，直接2*size，数量大于size，扩容数量n+size
④下标有越界风险，没有范围检查
⑤会迭代器失效（自动扩容时之类），会用迭代器erase删除时出问题。解决方法就是每次迭代器重定向
⑥作为priority queue的底层
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688442095710-4a0df588-1405-4cfd-854e-d28f390536cd.png#averageHue=%23fdf9f6&clientId=u9fc2cd8f-e9b7-4&from=paste&height=437&id=ud9158f56&originHeight=546&originWidth=1165&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=81202&status=done&style=none&taskId=u23e30491-4b3a-442f-aca1-2e8ac61b20e&title=&width=932)

##### （3）deque
① 序列式容器，双端队列，双头都可以删除和插入（比vector多push_front，pop_front），使用动态数组底层
②支持下标访问，支持迭代器，支持size()，**不支持任意删插入（erase，insert）（list，vector都支持）**
③**底层实现：**deque是由多个片段组成的，片段之间是不连续的，片段内部是连续的。如果将片段看成一个结点，那么deque看成是链表，片段内部是连续的，可以看成是vector。他不会像 vector 那样进行大规模的内存重分配：当 deque 扩容时，它会分配一个新的缓冲区，并将其链接到原来的缓冲区链表中，而不像 vector 那样需要复制所有元素。这意味着 deque 的扩容操作相对更加高效。
④ 会迭代器失效（自动扩容时之类），会用迭代器erase删除时出问题。解决方法就是每次迭代器重定向。
⑤它会提供边界检查，**不会发生越界访问**
⑥可作为stack和queue的底层
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688442110085-2c3b98c2-ce28-4914-b209-23a45b4b3462.png#averageHue=%23fdfbfa&clientId=u9fc2cd8f-e9b7-4&from=paste&height=402&id=u03979f8b&originHeight=502&originWidth=899&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=51916&status=done&style=none&taskId=u3c602f3d-4620-4388-913f-a2a95ec2839&title=&width=719.2)
##### （4）list
①序列式容器，双向链表，支持迭代器，**不支持下标访问（其他俩都支持）**，支持头尾插删，支持中间任意插删
②**底层实现：**底层实现：list 使用双向链表作为底层实现。每个节点都包含了指向前一个节点和后一个节点的指针，这使得在任意位置进行插入和删除操作更加高效，不会像 vector 或 deque 那样导致大规模的内存重分配。
③ **不会导致迭代器失效（其他俩都会失效）**
④生来就是为了高效任意位置插删的
⑤有一些独有的函数用法：unique，sort，merge，splice
⑥clearvector和deque只是清空数据，clearlist直接删除存储空间
**⑦如果需要在末尾进行频繁的插入和删除操作，并且需要随机访问元素，可以选择vector。**
**如果需要在前端和后端进行频繁的插入和删除操作，并且需要随机访问元素，可以选择deque。（内存大vector）**
**如果在其他位置进行频繁的插入和删除操作，并且不需要随机访问元素，可能需要考虑其他容器类型，如list。**

##### （5）set、multiset和unordered_set
①**set**有序关联式容器，key值按序排列，元素自动排序，key唯一，有迭代器
②**set**红黑树底层，可随意插入，**不可修改（四种set都不可）**，**不可下标访问（四种set都不可）**
③**set**支持**find()和count()**（set和map8种类型都支持）
④**set**提供了高效的插入、删除和查找操作（不可修改），效率都是O(log n)
⑤**set**可以自动去重，是因为底层有**insert_unique**函数
⑥**multise**t**（有序关联式容器）**和set一样，只是允许了多个重复key
⑦**unordered_set（无序关联式容器）**底层是哈希表，key值不按序排，其他和set一样。unordered_set的插入、查找和删除操作的平均时间复杂度为O(1)
**⑧如果需要有序存储且不允许重复元素，可以选择set；如果需要有序存储并允许重复元素，可以选择multiset；如果不需要有序存储且不需要考虑重复元素，可以选择unordered_set以获得更好的性能。**
⑨如果容器中存放的key值是自定义类型的时候，需要针对key值进行写std::less或者std::greater。包括三种形式：将std::less或者std::greater进行模板的特化、重载小于符号或者大于符号、自定义函数对象。(同map几类)

##### （6）map、multimap和unordered_map
①**map**有序关联式容器，key-value存储，key值按序排列，元素自动排序，key唯一，有迭代器
②**map**红黑树底层，可随意插入，**可修改（四map都可），可下标访问（除了他和unordermap，其他都不可）**
③**multimap（有序关联式容器）**和map一样，只是允许了多个重复key，并且不支持下标
④**map**支持**find()和count()**（set和map八种类型都支持）
⑤**unordered_multimap**也不支持下标访问
⑥**unordered_set（无序关联式容器）**底层是哈希表，key值不按序排，其他和set一样

##### （7）关联式容器总结（8种）
①他们用起来没有任何区别，每个函数都可以用。
②有的用hash，有的用红黑树。前者unordered的性能更好o[1]，后者有序o[logn]，序列式o[n]
③只有map和unordered_map可以下标访问
④四种map可修改，set不可修改
⑤**无序关联容器**key进行**自定义**时，需要针对key值进行写std::hash与std::equal_to。std::hash不是运算符，而需要设计哈希函数，所以就只有两种形式：将std::hash针对于自定义类型 进行特化、函数对象的形式std::equal_to包括三种形式：将std::equal_to进行**模板的特化**、**重载等号运算符**、**自定义函数对象**。
⑥**序列式容器k**ey值是**自定义**类型的时候，需要针对key值进行写std::less或者std::greater。包括三种形式：将std::less或者std::greater进行**模板的特化**、**重载小于符号或者大于符号、自定义函数对象**

```c
//重载运算符operator>
bool operator>(const Point &lhs, const Point &rhs)
{
    /* cout << "bool operator>(const Point &, const Point &)" << endl; */
    if(lhs.getDistance() > rhs.getDistance())
    {
        return true;
    }
    else if(lhs.getDistance() == rhs.getDistance())
    {
        /* if(lhs.getX() > rhs.getX()) */
        if(lhs._ix > rhs._ix)
        {
            return true;
        }
        else if(lhs._ix == rhs._ix)
        {
            if(lhs._iy > rhs._iy)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        else
        {
            return false;
        }
    }
    else
    {
        return false;
    }
}

//函数对象的形式
struct ComparePoint
{
    bool operator()(const Point &lhs, const Point &rhs) const
    {
        /* cout << "struct ComparePoint " << endl; */
        if(lhs.getDistance() < rhs.getDistance())
        {
            return true;
        }
        else if(lhs.getDistance() == rhs.getDistance())
        {
            if(lhs._ix < rhs._ix)
            {
                return true;
            }
            else if(lhs._ix == rhs._ix)
            {
                if(lhs._iy < rhs._iy)
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            else
            {
                return false;
            }
        }
        else
        {
            return false;
        }

    }
};

#if 1
//命名空间是可以进行扩展的
namespace std
{
//模板的特化(全特化)
template <>
struct less<Point>
{
    bool operator()(const Point &lhs, const Point &rhs) const
    {
        /* cout << "struct std::less<Point> " << endl; */
        if(lhs.getDistance() < rhs.getDistance())
        {
            return true;
        }
        else if(lhs.getDistance() == rhs.getDistance())
        {
            if(lhs.getX() < rhs.getX())
            {
                return true;
            }
            else if(lhs.getX() == rhs.getX())
            {
                if(lhs.getY()< rhs.getY())
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            else
            {
                return false;
            }
        }
        else
        {
            return false;
        }
    }
};
}
#endif

    /* priority_queue<Point> pque; */
    /* priority_queue<Point, vector<Point>, ComparePoint> pque; */
    /* priority_queue<Point, vector<Point>, std::greater<Point>> pque; */
   // priority_queue<Point, std::deque<Point>, std::greater<Point>> pque;
```


##### （8）容器适配器
①stack，queue，priority queue
②**priority queue，底层用大顶堆实现，底层容器：通常使用std::vector**

![image-20230724115417040](C:\Users\范劲松\AppData\Roaming\Typora\typora-user-images\image-20230724115417040.png)

**（9）函数适配器bind**
①bind1st，bind2nd，分别可以绑定定二元函数对象f的参数，使其变为一元函数
②**函数指针**可以注册回调函数，并使用。函数指针在c里面很像c++里面的多态，不过函数的类型需要吻合才行。
**bind**的使用和函数指针的使用的区别就是，bind可以使函数参数有待传值，也可以缺省，他们与函数的参数位置一一对应，多余的直接删去。而函数指针必须严格吻合
③**bind**用于创建一个函数对象，该函数对象可以绑定到特定的函数或成员函数，并且可以延迟执行
④**bind**默认值传递（复制）。可以改变函数的形态（参数个数）
⑤**bind**可以绑定各种函数，成员函数，甚至数据成员，绑一切

##### （10）函数适配器function和mem_fn
①**function**可存储各种函数类型，比如函数指针，成员函数指针，函数对象。被称为函数的容器
②function与bind结合，可以实现函数的封装，多态，可以实现回调函数的注册和使用
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688464272761-fba09972-a9de-4ff1-8c0b-ff820c317506.png#averageHue=%23fdfdfd&clientId=u76b4a7d9-a029-4&from=paste&height=140&id=u576975fd&originHeight=175&originWidth=763&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=72144&status=done&style=none&taskId=uf603a9e7-52d2-46a4-b8e5-8dca3fa7eac&title=&width=610.4)
③**回调函数：**回调函数将一个函数作为参数传递给另一个函数，并被调用。
注册回调函数是指将一个函数作为回调函数注册到另一个函数中，以便在需要时被调用。通常，注册回调函数涉及将回调函数的指针或函数对象传递给接受回调函数的函数（用bind）。接受回调函数的函数（用function）将保存回调函数，并在适当的时候调用它。
③**mem_fn**是把一个成员函数转换成一可调用的函数对象。函数对象的功能是借助成员函数实现。bind可替代他

##### （11）函数对象
①函数对象是可以以函数方式与()结合使用的任意对象
②通常有以下几类：函数名、指向函数的指针、重载了()操作符的类对象(即定义了函数operator()()的类)

##### （12）算法
①非修改式的算法：count、fifind、for_each
②修改式的算法：copy、remove_if
③排序操作（快排，堆排）：sort
④集合操作：set_intersection
⑤与堆相关的操作：make_heap
⑥二分查找
⑦求最大值、最小值：max、min
⑧内存相关操作：uninitialized_copy，空间配置器

##### （13）迭代器
①概念：迭代器可以看成是一种智能指针。扮演容器与算法之间的胶合剂，是所谓的“泛型指针”。从实现⻆度来看，迭代器是⼀种 将 operator *, operator ->, operator++, operator– 等指针相关操作予以重载的class template。
②本质：是种更高层次的抽象，它使得算法独立于容器。
③还有插入迭代器。反向迭代器
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688475055907-0a118e3d-5531-474c-addb-d86c63fe3de3.png#averageHue=%23f9f9f9&clientId=u76b4a7d9-a029-4&from=paste&height=215&id=u338acdb9&originHeight=269&originWidth=603&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=45183&status=done&style=none&taskId=u94e57e02-dff7-4587-add7-5e2e50e8978&title=&width=482.4)


##### （14）空间配置器
①**定义**：负责空间的配置与管理（主要是容器）。从实现⻆度看，配置器是⼀个实现了动态空间配置、空间管理、空间释放的class tempalte. 
②**把空间的申请和对象的构建分开**：如果不分开，那么创建对象比较多的时候，那么每创建一个对象就需要申请空间，那么申请空间就比较频繁，就比较耗时。
③**四个函数**
```c
#include <memory>
//申请原始的未初始化的空间
T* allocate( std::size_t n );

//释放空间
void deallocate( T* p, std::size_t n );

//在申请的空间上，构建对象。函数接受⼀个指针 P 和⼀个初始值 value，该函数的⽤途就是将初值设定到指针所指的空间上。
void construct( pointer p, const_reference val );

//销毁对象，函数有两个版本，第⼀个版本接受⼀个指针，准备将该指针所指之物析构掉。直接调⽤析构函数即可。第⼆个版本接受 first 和 last 两个迭代器，将[first,last)范围内的所有对象析构掉。
void destroy( pointer p );

```
④**配置空间：分为一级配置器和二级配置器**
**⑤一级配置器：**第⼀级配置器以 malloc(), free(), realloc() 等 C 函数执⾏实际的内存配置、释放和配置操作。allocate() 和 reallocate() 都是在调⽤malloc() 和 realloc() 不成功后，如果内存满了，改调⽤oom_malloc() 和oom_realloc()，他们有内循环查内存。
⑥**二级配置器：**第⼆级配置器多了⼀些机制，专⻔针对内存碎⽚。精髓是**memory pool。**
主要就是维护16个链表**free-list（union）**，他们各自管理大小为8的倍数的小额区块，分别8,16,24,32,40,48,....,128bytes的小额区块。每次有内存需求，就从free_lists中拨出，如果客端释还小额区块，则回收到free_lists中。每次分配的需求量配置器会主动上调至8的倍数。
其维护的函数有配置函数**allocate()**，释放函数**deallocate()**，以及free_list不可用时的填充函数**refill（）**。
⑦每当有**allocate()**，先判断是否大于128，否就去找对应大小的free-list指针，找到发现空间，直接分配空间。是的话就直接用 malloc(), free(), realloc() ，oom_malloc() 和oom_realloc()**（内存不够时）**
⑧每当有**deallocate()**，先判断是否大于128，否就去找对应大小的free-list指针，将指向内容回收，并改指向。是的话就是直接free将内存回收到堆空间。
⑨当**allocate()，**小于128，找到free-list指针，发现没空间了，这时候使用**refill（）**
**⑩refill（）。**当发现 free_list 中没有可⽤区块时，就会调⽤ refill() 为free_list 新填充空间， 新的空间将取⾃内存池（经由 chunk_alloc() 完成），缺省取得20个新节点（区块），但万⼀内存池空间不⾜，获得的节点数可能⼩于 20。
chunk_alloc() 就是一蓄水池，能查到内存池有多少
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688479931419-25b5c3ec-434f-4c90-9293-ee92562c2adb.png#averageHue=%23f9f2ea&clientId=u76b4a7d9-a029-4&from=paste&height=427&id=u6ecd1167&originHeight=534&originWidth=1240&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=225523&status=done&style=none&taskId=u8186cce2-2d75-4306-b8b2-d71848fddae&title=&width=992)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688480264505-5f12c9b4-60bd-4cc8-b78e-bfada0ba34c2.png#averageHue=%23fbf6f0&clientId=u76b4a7d9-a029-4&from=paste&height=310&id=u9ec6d3b9&originHeight=387&originWidth=926&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=114325&status=done&style=none&taskId=u46aac9cd-9b63-45e8-a87f-6e5cd6cff2e&title=&width=740.8)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688480275138-f5b2574a-fd59-46da-9b9f-ea3652bff358.png#averageHue=%23fcf5ee&clientId=u76b4a7d9-a029-4&from=paste&height=458&id=u24329a41&originHeight=573&originWidth=898&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=197691&status=done&style=none&taskId=ude79674e-a929-4dfe-90d4-aaee924e8a0&title=&width=718.4)

#### 29、栈和堆的单独使用
##### （1）栈堆的区别
①栈快堆慢，字符串的sso利用这点
②栈自动申请和释放，堆手动申请和释放（new，malloc，delete，free）
malloc/free 是标准库函数，new/delete是c++的表达式/操作符，destory是包装好的delete或者free
③栈由高到低自上而下，堆自下而上
④栈存局部变量，函数调用。堆会产生内存碎片
⑤栈快堆慢，字符串的sso利用这点

##### （2）只用栈
①对于栈对象（new）来说，要同时要求**构造函数和细狗函数都放在public区（能用栈）**
②**将运算符new/delete进行重载，放到private区域（不能生成堆）**。Student *s2 = new Student()申请堆空间时，就算将~Student()放在private区域也没关系，因为申请的堆空间必须主动delete掉才行，所以delete必须要能调用
③Student s1 申请栈空间时，构造函数与析构函数都必须放在public区域里面，如果将~Student放在private区域，由于析构函数是自动调用的，所以Student s1语句会显示错误;

##### （3）只用堆
①**将细狗函数放到private里（不能生成栈对象了）**，**将运算符new/delete在public里（能用堆）**
②**调用细狗函数并不是回收对象本身**，回收的是标识字符串所指的空间。对象本身所在的空间是被operator delete库函数回收。所以堆更需要delete，栈更需要析构函数
③但是注意：直接调用析构函数已经是不可能，因为析构函数已经在private区域内部，所以需要在类内部创建destory函数，这样在destory函数内部使用delete就可以被动调用析构函数了

#### 30、http特点、如何保证数据在传输过程中的安全性
##### （1）http特点
①无状态（这次请求和上次请求无关），方便水平拓展（成本低）
②c/s。一问一答，类似于函数调用（远程函数调用），有事务的概念
③文本形式。报文头是字符串，可见（tcp是二进制形式）
④可靠（建立在tcp之上）

##### （2）http传输时的安全性
①http明文传输
②htttps加密传输，同时用到对称加密和非对称加密
③对称加密（DES）：双方都有同一把秘钥，发之前秘钥加密，解用秘钥解
④非对称加密（RSA）：有公钥和私钥，接收方把公钥传给发送方，发送方收到公钥加密后发给接收方，私钥解密
⑤https发送公钥时用非对称加密，传输时用对称加密


#### 31、整体过程面试题
##### （1）一个网页请求从头到尾要用到的协议
①应用层**（第一步域名解析）**：
使用**DNS**（Domain Name System）协议来解析域名。DNS将域名转换为对应的IP地址，以便进行网络通信。
DNS查询可以采用递归方式，即向根域名服务器逐级查询，直到找到所需的IP地址，先差浏览器DNS缓存，再差os缓存，再查oshost。也可以采用迭代方式，即依次查询各级域名服务器。

①网络连接：
互联网有线网：使用I**EEE 802.3**协议（以太网），采用总线型拓扑结构。头部为6 6 2 46 4。
无线网：使用**IEEE 802.11**协议（Wi-Fi）（BSS AP），采用星型拓扑结构。

②数据链路层：
使用**CSMA/CD**（有线局域网,，载波监听多路访问碰撞检查，回避算法）（传播时延，传输时延，**最短帧**长）
**CSMA/CA**（无线局域网,，载波监听多路访问碰撞检查，回避算法）
进行数据链路传输，它是应用于解决同一冲突域多个用户之间访问冲突
使用**GBN（Go-Back-N）**（滑动窗口和后退N帧，顺序接收帧，捎带确认，接收窗口1）
**SR（Selective Repeat）**（滑动窗口和选择重传，根据对应的发送确认帧，直到接收窗口从头开始有才移动）
这些协议可以实现控制流量，可靠的数据传输，确保数据的完整性和顺序性。

③网络层：
在移动设备环境下，可能会先使用移动IP协议**DHCP**（动态主机配置协议）udp**广播**。移动IP允许设备在不同的网络中保持连接，并能够在移动时保留其IP地址。
如果用户要点开直播页面，可能会使用**IGMP**（Internet Group Management Protocol）协议来多播组管理。
地址解析协议（**ARP**）：
**ARP**用于通过目标IP地址查找对应的物理地址（MAC地址），先找本地的表。
**ARP**会在局域网中广播请求，以查询其他节点的转发表（仅适用于IPv4）。
如果在局域网中没有找到目标地址的物理地址，则会将数据包发送到默认网关地址。
当数据包发送到路由器时，可能会使用网络地址转换**NAT**技术对源IP地址和目标IP地址进行转换，以便在不同网络之间进行通信。

⑤路由器分组转发：
路由器之间使用动态路由协议来存储和转发数据，常见的协议包括**RIP**（Routing Information Protocol）、**OSPF**（Open Shortest Path First）和**BGP**（Border Gateway Protocol）。
**RIP**是一种基于距离向量的内部网关协议，传邻居全部信息，用于在小型网络中进行路由选择。（UDP）
**OSPF**是一种链路状态协议，洪泛法，传全部扔更改信息，用于在中型到大型企业网络中进行内部路由选择。
**BGP**是一种路径向量（发言人）外部网关协议，用于在不同的自治系统之间进行路由选择。（TCP）
路由分组转发会找路由器的路由表，看转发的下一结点在哪，没有的话就把吓一跳转给默认路由器

⑥错误处理：
如果在传输过程中出现错误或超时，会使用**ICMP**（Internet Control Message Protocol）返回相应的错误信息。ICMP可用于报告网络连接问题、主机不可达和其他网络层错误。（ping）

⑦域名解析后，网络准备好后的传输层之上的流程：
在传输层，常用的协议有**TCP**（Transmission Control Protocol）和**UDP**（User Datagram Protocol）。
**TCP**提供可靠的、面向连接的数据传输，确保数据的完整性和顺序性。它使用握手和确认机制来实现可靠性。
**UDP**是一种无连接的传输协议，它不提供可靠性保证，但传输速度较快。UDP适用于对实时性要求较高的应用，如音频和视频流传输。
tcp三次握手，握手后发送http请求，相应http请求后，浏览器解析html代码，再断开四次挥手tcp（看http是持久非持久）。
浏览器通常使用HTML、CSS、JavaScript等技术进行页面渲染和交互。

⑨报文头和端口：
根据报文头中的协议标识来确定所使用的协议。
如果报文头指示使用**HTTP**协议（端口80或443），则进行网络传输，用于浏览网页。
如果报文头指示使用**FTP**协议（端口20或21），则用于文件传输。
如果报文头指示使用**SMTP**协议（端口25）或**POP3**协议（端口110），则分别用于发送和接收电子邮件。

##### （2）HelloWorld 程序开始到打印到屏幕上的全过程
①操作系统：找到helloworld程序的相关信息，检查其类型是否是可执行文件；并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址。
②操作系统：创建一个新进程，将HelloWorld可执行文件映射到该进程结构，由该进程执行 helloworld程序。
③操作系统：为helloworld程序设置cpu上下文环境，并跳到程序开始处。
④执行helloworld程序的第一条指令，发生缺页异常
⑤操作系统：分配一页物理内存，并将代码从磁盘读入内存，然后继续执行helloworld程序
⑥helloword程序执行puts函数（系统调用），在显示器上写一字符串
⑦操作系统：找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以，操作系统将要 写的字符串送给该进程
⑧操作系统：控制设备的进程告诉设备的窗口系统，它要显示该字符串，窗口系统确定这是一个合法 的操作，然后将字符串转换成像素，将像素写入设备的存储映像区
⑨视频硬件将像素转换成显示器可接收和一组控制数据信号
⑩显示器解释信号，激发液晶屏


##### （3）执⾏⼀个系统调⽤时，OS 发⽣的过程，越详细越好
①执行用户程序时出现在内核态才能用的操作（如fork）
②根据函数实现，获取系统调用号，并产生访管中断访管指令（中断的种类和详细过程）
③进入内核模式，地址空间转换和栈堆的保存切换
④进行中断处理，根据系统调用表调用内核函数
⑤执行内核函数
⑤执行restoreall，返回用户态

#### 32、TCP的第三次握手没有回发生什么、DDOS攻击、TCP的每个连接（断开）的阶段名、TCP首部

#### 33、lambda表达式

#### 35、排序算法

#### 36、proxy代理模式
（1）代理模式是一种设计模式,它提供了一个代理对象来控制对一个对象的访问
（2） 继承:通过继承基类实现代理类
```cpp

class Base {
    public:
    void DoSomething();
};

class Proxy : public Base {  
public:
void DoSomething() override {
    // 增加一些附加代码
    Base::DoSomething(); 
}
};

```
这里`Proxy`类继承了`Base`类,实现了`DoSomething()`方法。`Proxy`类的`DoSomething()`方法中,首先执行一些附加的代码,然后再调用基类的`DoSomething()`

（3）组合:通过组合基类对象实现代理类。
```cpp
cpp
class Base { 
 public: 
  void DoSomething();
};

class Proxy {
 private:
  Base *base;
 public: 
  Proxy(Base *base) : base(base) {}
  void DoSomething() {
    // 增加一些附加代码
    base->DoSomething();
  }  
};
```
这里`Proxy`类包含一个`Base`类的实例,在`DoSomething()`方法中,首先执行附加代码,然后调用基类实例的`DoSomething()`方法。代理模式的优点是:可以在调用对象方法前后加入附加操作,在不修改原对象的基础上实现额外功能。

## 三、工作中出现的问题以及解决方法
### （一）死锁问题
**1、调试的时候发现有两个线程同时卡在加锁解锁部分，于是调整锁的顺序，来解决死锁**
**2、调整锁的顺序属于是破坏死锁的循环等待条件**
**3、从而引出死锁的四个必要条件**
①互斥 
②请求和保持 
③循环等待 
④不可剥夺条件
**4、从而引出死锁的处理策略**
①死锁的预防（破坏四个必要条件之一）
②死锁的避免（用银行家算法（预分配资源后进行安全性算法检查））
③死锁的检测（简化资源检测图）
④死锁的解除（资源剥夺、撤销进程（SIGKILL）、进程回退（设置还原点））
**5、死锁的种类**
①多个锁加锁顺序有问题
②线程终止时持有锁
③一个线程在加锁的情况下，对同一把锁再加锁（②③锁不会）
**6、锁的类型**
①普通锁（优先使用）
②检错锁（不可对一把锁加锁）
③可重入锁（对同一把锁加锁会+1）
④自旋锁
⑤读写锁
**7、加锁的操作**
①lock（阻塞）
②trylock（非阻塞）

### （二）工作中遇到的网络问题 
1、定位问题
2、分析原因，根据协议找到是哪个阶段的原因
3、分析代码再抓包用tcpdump抓包
4、wireshark来分析

### （三）工作技巧 
1、刚去公司 为了表现自己 ： 自己干的活，能打造人设的，都要让别人看得到
2、把公司的库先了解一下整体的架构，再把所有的接口导出，一个一个背（当着别人的面背）
### 
### （四）验证数据是否成功传输过程中 数据发生错误怎么办（怎么验证）
1、在服务端再算一次md5来验证一下跟客户端传来的md5一样
2、md5冲突怎么办   --- 可以再比较一下文件长度等 补充额外信息来判断        
3、或者更换shell1（hasn信息）

### （五）公司程序用的线程数，服务器的规模
1、我有16 32个子线程 用的线程库是什么。nptl线程库
2、浪潮服务器  20核

### （六）有个东西特别卡怎么办呐
1、ps -elf
2、看cpu使用率
3、free
4、看内存使用率valgrind --tool=memcheck ./a.out
5、看buf
6、看看有没有缓存雪崩（不重要）

### （七）安装第三方库方法
1、拉包解压，cd到文件下比如（cd log4cpp）
2、./configure
3、make
4、sudo make install
5、sudo ldconfig
6、拉到vs等工具中阅读源码
7、把简单用例跑一下看看，里面的函数和参数照着源码和参考网站来找到用法
    自己通过参考文件改测试用例里的参数，边改边学习

### （八）gdb调试（解决coredump）
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688128063105-ac60557d-88ac-4565-9b46-39f48f0696b7.png#averageHue=%23f8f1ef&clientId=u2aa1c3bf-40c5-4&from=paste&height=584&id=u98196ce5&originHeight=730&originWidth=770&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=281617&status=done&style=none&taskId=u9342314c-afcb-49bd-8fdb-431527f3f11&title=&width=616)


## 四、项目问题以及个人负责部分（难点，要点）
### （一）项目细节
#### 1、项目代码多少行
        没统计过，不过十几万行是有的
#### 2、代码怎么维护
gitee
SVN
ao日志系统写周报日报
出现bug就通过bug管理系统指派给工程师
研发完成提交测试，提测
#### 3、每期如何达到验收标准
公司有专门的团队来执行，我只写代码和bug

### （二）客户运营信息可视化项目（我做了其中一个模块）





![引擎话术](C:\Users\范劲松\Desktop\面试话术\引擎话术.png)

#### ![引擎话术2](C:\Users\范劲松\Desktop\面试话术\引擎话术2.png)1、项目描述
该项目是对本公司服务的各个企业的客户运营信息进行可视化管理，方便公司内部人员和企业工作人员查看。
我负责的是这个项目的一个子项目——**检索引擎模块**
简单来说就是把公司提供给各企业的客户运营方案做成一个网页搜索引擎模式，方便查阅和检索
该项目在Linux下用C/C++完成 C++11 ubuntu18.0
这个搜索引擎旨在提供快速和并发的搜索，功能实现度和破产版百度相似
他能支持中英文混合检索，中英文网页查询，关键字联想推荐，网页信息整理返回

#### 2、技术要点
##### （1）reactor（反应堆）
①整体是I/O复用 I/O非阻塞 （read write不会堵住）
②**I/O 多路复用监听**事件，收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程
③有acceptor类，socket类，socketio类，tcpconnection类，eventloop类，evtfd通信描述符，efd事件描述符
connect描述符。大部分都是组合关系
④计算类交由线程池中的工作线程去做，让线程池处理业务逻辑。让Reactor，也就是EventLoop处理IO操作，这样就可以处理计算量大的问题。
⑤**TCP三个半事件：**链接建立，链接断开，消息到达，消息传输完毕（半个）。这三个半事件都在tcpconnection类里注册和使用，但因为需要在eventloop（中转）中使用这几个tcpconnection的方法，就需要在eventloop里面使用前先重新注册一下这三个事件，会先跳转到tcpconnection将其注册完成（具体实现是在tcpconnection里面的），之后epoll再使用这个回调函数，同样也是跳转到tcpconnection里面先判定是否已经注册完成这个事件，注册完成之后，通过调用 _onConnectionCb 函数并传递 shared_ptr 指向当前的 TcpConnection 对象，来执行回调函数。
⑥线程池做完工作需要用evtfd通知eventloop，evtfd是个进程线程间通信的文件描述符，小于零就阻塞。同时eventloop中监听着evtfd，当有通信时，tcpconnection把处理后的信息以及发送信息的能力（函数）一起传送给eventloop（有一个对应的list结构接收），再通过eventloop通过doPendingFunctors进行传送客户端
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1689168484842-db1f3785-700a-42bf-95d9-59c465b9c1b1.png#averageHue=%2396d861&clientId=u0c515707-11cc-4&from=paste&height=659&id=u3084a0b4&originHeight=824&originWidth=620&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=228957&status=done&style=none&taskId=uf58721d3-bf5f-437c-a2ee-67024a231ec&title=&width=496)

##### （2）epoll（与select和poll的区别）
①相同：进程可以通过一个系统调用函数从内核中获取多个事件socket
②select：每次都要把fdset从用户态拷贝到内核态。fdset（文件描述符集合）采用位图的设计，大小相对固定，监听集合和就绪集合耦合在一起。每次从select，要遍历所有的监听文件描述符。一共要两次遍历fdset（内核态，用户态各一次）O[n]，两次拷贝fdset（用户到内核态，内核修改后再到用户），非常慢1024
③poll：poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。并且也是一共要两次遍历fdset，两次拷贝fdset。
④epoll：事件驱动机制**监听集合是红黑树O[logn]，就绪集合是线性表**
有边缘触发和水平触发，epoll 支持边缘触发和水平触发的方式，而 **select/poll 只支持水平触发**，一般而言，边缘触发的方式会比水平触发的效率高，**边缘触发模式一般和非阻塞 I/O 搭配使用**
**边缘触发**
边缘触发模式仅在状态发生变化时通知应用程序。
当事件状态从非就绪状态（如未就绪）变为就绪状态时，会触发通知。
应用程序需要立即处理就绪事件，以避免错过事件。如果应用程序没有及时处理事件，事件会被视为已处理，而不会再次触发通知。
**水平触发**
水平触发模式会持续通知应用程序，只要事件处于就绪状态。
只要事件状态保持在就绪状态，就会持续触发通知。
应用程序可以在任意时间点处理就绪事件，不需要立即处理。事件会一直触发通知，直到被处理为止。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1687962082954-2decc27b-3f8a-46b9-93ba-54090125d4cc.png#averageHue=%23f4f4f4&clientId=u870dc056-0e62-4&from=paste&height=101&id=u2724a1ba&originHeight=126&originWidth=391&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=23563&status=done&style=none&taskId=u97015596-943b-4de9-977e-7f781a540a9&title=&width=312.8)	

##### （3）线程池
①主进程接收任务之后，如果把他们丢给子进程或者其他进程，会进行大量的进程间切换（引入），线程切换更方便
②16子线程nptl线程库posix线程库
③遇到的难点（bug）
a.线程池中的任务执行不完
措施：发现线程池会自动退出，需要在线程池终止成员函数内部的实现加上一个遍历任务队列的代码，如果任务队列还有认为，线程池的stop函数就阻塞住
b.线程池无法正常退出
找到原因后发现线程入口函数中出现了有线程睡眠
之后发现是子线程拿到任务之后处理太快了，处理完就直奔取任务，但这个时候线程池终止成员函数还没把isExit设为1，于是子线程就成功去取任务的路上发现没任务，睡眠自己，导致线程池也关不了
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688030431676-5ad127d6-d1bd-44c5-9879-2b2cef008583.png#averageHue=%23fdfdfd&clientId=u74123019-901e-4&from=paste&height=708&id=u494a544d&originHeight=885&originWidth=1090&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=59644&status=done&style=none&taskId=u44b886ff-c846-4efb-b2d0-35fb908049b&title=&width=872)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688030451194-6102ce84-4a8a-4a18-aac9-997fe9e92e64.png#averageHue=%23faf9f9&clientId=u74123019-901e-4&from=paste&height=605&id=u00622f3c&originHeight=756&originWidth=1642&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=116097&status=done&style=none&taskId=ufc93be5b-5bed-4194-b5a4-986e3c6fbc4&title=&width=1313.6)

##### （4）离线部分（网页）
①生成网页库，网页偏移库
②为每个网页提取网页中的特征码，特征码为该网页中词频（就是一个词在该网页中出现的次数）最高的 10 个词----top10 词，去重 simhash（用几个关键词代替一个文章，关键词进行32位hash二进制编码，再把编码相加得到文章的代替二进制值，计算两个simhash的相似度通常使用汉明距离
③海明距离说白了就是计算两个编码相对位置不相同的个数，就是一组二进制数据变成另一组数据所需的步骤
④扩展海明码。先在1248处加上校验位，再根据0001 0010 0100 1000，来分剩下的位置中有上述1存在的位置，如（1对应1,3,5,7,9,11），一共为偶数个的1的话就把这位校验位当成1（奇偶校验的原理） （困难点）
④生成倒排索引库（用TF-IDF算法算出w权重值）

[机器学习：生动理解TF-IDF算法 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/31197209)

##### （5）离线部分（关键字）
①英文词典库（单词 + 词频） 英文索引库（字母 + 行号）
②中文词典库 中文索引库 cppjieba分词

##### （6）在线部分（关键字）
①基于上述的四个库，先拆分客户端传来的关键字成一个个的字（字母），找出每个字组成关键字出现的频率
②再用最小编辑距离算法，得到最适合的关键字组合，以及最小编辑距离
当最小编辑距离相同的时候，在比较单词的频率，频率越高，就排在前面，频率越低，就排在后面。 
当最小编辑距离相同的时候，频率也相同，就按照字母序进行排序。
③最小编辑距离算法 [https://blog.csdn.net/baodream/article/details/80417695](https://blog.csdn.net/baodream/article/details/80417695) 动态规划
④中英文有区别。utf-8，中文一个字符是三个字节，英文一个字符是一个字节 
⑤扩展最短距离Dijkstra算法。贪心算法 （当时想用出现的频率来用dijkstra，发现不合适） （困难点）

##### （7）在线部分（网页）
①余弦相似度算法
②首先把传过来的关键词组合进行cppjieba分词，把关键词组合当成一篇文章，计算不同词的TF-IDF，w值，组成一个向量
③通过倒排索引库找到每个关键词所包含的文章id，取交集，找到符合的所有文章
④通过计算每个关键词在每个文章中的w，来组成一个向量
⑤和上面那个向量计算cos值，取最大的几个cos的文章
⑥离线库每次加载浪费时间，选择当天的东西先放到内存里

##### （8）**Redis和cacheLRU**
①关键字cacheLRU：线程池开启时，根据每个线程创建其对应的cache，之后可以通过线程局部变量进行访问
②线程局部变量（TLS）：这个变量在它所在的线程内是全局可访问的，但是不能被其他线程访问到，这样就保持了数据的线程独立性。而熟知的全局变量，是所有线程都可以访问的，这样就不可避免需要锁来控制，增加了控制成本和代码复杂度。
③每个缓存内部采用 LRU 算法对冷数据进行淘汰。当工作一段时间后，每个缓存的内容会不一致，因此需要更新缓存。更新缓存的操作，交给一个定时器完成，每隔固定的时间，更新缓存数据。
④分有主cache（全局cache，在1号线程）和子cache，把子cache每次更新的数据（5s）同步到主cache中，主cache再把数据返回给各个子cache（10s），并做持久化（放到磁盘中）。每次开系统时，将磁盘数据加载到主
⑤LRU缓存的淘汰算法，list中存放的是数据（key,value），查找速度是O(N),然后使用unordered_map，其中存储的是元素在list中的迭代器
②网页Redis，把redis的方法写成一个类，在关键词查询和网页查询里，先调用redis的方法进行从磁盘里读取数据，再读redis中的数据，如果没有话再直接读库中的数据并且把它更新到redis中。

> I/O多路复用
> [https://mp.weixin.qq.com/s/Qpa0qXxuIM8jrBqDaXmVNA](https://mp.weixin.qq.com/s/Qpa0qXxuIM8jrBqDaXmVNA)
> 
> reactor和proactor
> [https://www.xiaolincoding.com/os/8_network_system/reactor.html#proactor](https://www.xiaolincoding.com/os/8_network_system/reactor.html#proactor)



### （三）企业信息化上云项目（我做了其中一个模块）
#### 1、概况
（1）项目分两块，我做的部分是，用私有协议把关键用户数据这一部分在服务器上部署，并且可以通过网盘形式，不同的客户端上同时使用上传下载，寻址等功能。
（2）另一部分实现上传一部分是准备用通过http和srpc协议借助workflow框架api网关，做一个解耦的双端，把大量客户信息文件上传到OSS阿里云里。自己参与了部分，辅助做到一些Nginx和workflow的工作

#### 2、重点
##### （1）线程池
同上

##### （2）断点续传
①通过识别md5码，找到是否存在相同的表项或者文件路径
②计算他的大小，根据大小定位将要发送的文件流的的位置（lseek），再传输

##### （3）秒传
直接根据需要上传的文件的md5值，找数据库中是否含有相同md5值的表项，存在的话就秒传

**（4）长短链接业务分离（token）**
①用户链接后，服务端看是否有token值，如果没有那么命令只能是注册或者登录，将这种命令交给主线程直接完成。用户登录后，返回一个token值给用户（也可以返回两个，一个长token一个短token）
②如果有token值，根据用户名判断token值是否相等，相等的话分析发来的命令（解协议）。如果是长命令（get put），交给线程池来做，短命令就直接交给主线程来做。
③方法：通过设计一个结构体，里面包含着本次命令的id（两端做成协议），和token值

**（5）零拷贝**
①发现文件大于100M，就使用 mmap 该文件，然后再传输
②将用户态内存到内核态内存传输这一步骤取消，用户态内存和内核态内存映射到同一个页框
③发送的时候直接就是内核态之间传递数据（以前还要先从用户态到内核态）

##### （6）超时断开
①将客户端的连接加入到一个环形队列中，每一秒是环形队列的一格（用epoll的1000参数），格子里面是一个集合，里面装着这个时间中使用的fd，每一次加入新fd
②再创建一个哈希表，key为fd的值，value01，记录最近访问，在30s循环里访问过就设为1，否则为0
③循环队列每一秒往下遍历一格，通过队列格子里的集合里的fd的值，找hash表中的value，如果value值为0，就把fd踢出队列中，并从epoll的红黑树上删除。如果为1就设为0

##### （7）日志系统
①log4cpp
②写在头文件的宏里面

**（8）私有协议（粘包、半包）**
用小火车解决，规定一次包最大nkb，再规定每次先发长度，解决粘包半包（TCP流式协议无边界）

##### （9）密码验证 设置不同权限（用不同的用户有不同的假目录实现）
①用户注册的时候随机生成一个盐值，将其和密码明文一起通过crypt函数加密成密文
②用户登录的时候通过用户名找到数据库存储的盐值，传客户端，将其组合加密后对比存储的密码密文

## 五、实战面试
### （一）代码
#### 1、十进制数中二进制的个数
```c
int countOnes(int decimal) {
    int count = 0;
    
    while (decimal != 0) {
        if (decimal & 1) {
            count++;
        }
        decimal >>= 1;
    }
    
    return count;
}
```
#### 2、c语言写查出一串字符串中最长的元音字符串
```c
int isVowel(char c) {
    c = tolower(c);
    return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');
}

void findLongestVowelString(const char* str) {
    int len = strlen(str);
    int maxLen = 0;
    int maxStart = 0;
    int currLen = 0;
    int currStart = 0;
    
    for (int i = 0; i < len; i++) {
        if (isVowel(str[i])) {
            if (currLen == 0) {
                currStart = i;
            }
            currLen++;
        } else {
            if (currLen > maxLen) {
                maxLen = currLen;
                maxStart = currStart;
            }
            currLen = 0;
        }
    }
    
    if (currLen > maxLen) {
        maxLen = currLen;
        maxStart = currStart;
    }
    
    if (maxLen == 0) {
        printf("No vowel string found.\n");
    } else {
        printf("Longest vowel string: ");
        for (int i = maxStart; i < maxStart + maxLen; i++) {
            printf("%c", str[i]);
        }
        printf("\n");
    }
}


```
3、约瑟夫环
4、手搓循环队列（双向队列）
5、输入一行或从文件里读数据，判定数据类型，再放到另一文件里
6、观察者模式手搓

### （二）八股

**面试中问你在工作中怎么用Redis和MySql数据库怎么回答？都具体做些什么？存储什么数据？**

在工作中，Redis 和 MySQL 数据库都是非常常用的数据存储工具。下面是一些我在工作中使用 Redis 和 MySQL 数据库的例子：

Redis 数据库：
- 缓存：使用 Redis 缓存来提高网站的性能，减少对数据库的请求次数，例如缓存网站的页面、查询结果等。
- 队列：使用 Redis 作为消息队列，例如在后台处理任务时，将任务加入 Redis 队列，然后通过后台进程执行任务。
- 计数器：使用 Redis 计数器来跟踪应用程序中的某些事件，例如网站的页面浏览量、用户在线数量等。
- 数据结构：Redis 也可以用来存储数据结构，例如使用 Redis 的有序集合来存储排名、分数等。

MySQL 数据库：
- 存储关系型数据：使用 MySQL 来存储关系型数据，例如用户信息、订单信息等。
- 数据库备份：使用 MySQL 的备份功能，定期对数据库进行备份，以防止数据丢失。
- 数据库优化：对 MySQL 进行性能优化，例如通过索引来加快查询速度、使用分区表来优化大型数据表的查询性能等。

在存储数据方面，具体需要根据具体业务需求来选择。例如，对于 Redis 数据库，可以存储缓存数据、计数器、队列等；对于 MySQL 数据库，可以存储用户信息、订单信息、商品信息等。在存储数据时，需要考虑数据类型、数据结构、数据一致性等因素，以确保数据的正确性和可靠性。同时，在存储数据时，也需要考虑数据安全性，例如使用加密算法来加密密码等敏感信息。

**使用socket可以实现在不同主机之间完成通信，其主要过程如下：**

1. 创建socket

在客户端和服务器端分别创建一个socket，可以使用socket函数创建一个套接字。在创建套接字时，需要指定协议族、套接字类型和协议类型。通常情况下，采用TCP协议时，协议族为AF_INET，套接字类型为SOCK_STREAM，协议类型为IPPROTO_TCP；采用UDP协议时，套接字类型为SOCK_DGRAM，协议类型为IPPROTO_UDP。

2. 绑定端口和IP地址

在服务器端，需要将套接字绑定到一个端口和IP地址上，以便客户端能够连接到服务器。可以使用bind函数将套接字和端口绑定在一起。

3. 监听连接请求

在服务器端，需要使用listen函数将套接字设置为监听状态，以便能够接受来自客户端的连接请求。

4. 建立连接

在客户端，需要使用connect函数连接到服务器端。在连接函数中，需要指定服务器的IP地址和端口号。

5. 传输数据

一旦连接建立成功，客户端和服务器端就可以使用send和recv函数进行数据传输。在传输数据时，可以使用send函数将数据发送到对端，也可以使用recv函数从对端接收数据。

6. 关闭连接

在数据传输完成后，需要使用close函数关闭连接，释放相关的资源。

总结：

使用socket实现在不同主机之间完成通信的过程包括创建socket、绑定端口和IP地址、监听连接请求、建立连接、传输数据和关闭连接等步骤。在不同步骤中需要使用不同的socket函数和参数，具体使用方法可以参考相关文档和示例代码。

#### 1、const的作用
①const 是一个关键字，用于声明常量。常量是程序中固定不变的值，其值在声明后不能被修改。
②声明向量、增加程序可读性、编译器优化、防止魔法数

#### 2、static_cast和dynamic_cast的区别
①static_cast用于基本类型之间的转换，类似于int转换为char类型，有起到**编译时**的类型检查。
②dynamic_cast用于基类跟派生类之间的引用和指针的相互转换，有起到**运行时**的类型检查功能。
```c
// 示例 1: 类层次结构中的向下转型
class Base {
  virtual void foo() {}
};

class Derived : public Base {
  void foo() override {}
};

Base* basePtr = new Derived();
Derived* derivedPtr = dynamic_cast<Derived*>(basePtr); // 将基类指针转换为派生类指针
//dynamic_cast基类必须要有虚函数才行
```

3、内核态和用户态是什么

内核态权限最高

用户态权限较低

内核态一般与硬件有关



4、内存间通信方式

共享内存：共享内存是指多个进程或线程之间共享同一块物理内存，进程或线程可以直接访问这块内存，从而实现数据共享。使用共享内存需要进行同步和互斥操作，以确保数据的一致性和正确性。

消息传递：消息传递是指进程或线程通过发送和接收消息来进行通信。消息传递可以使用进程间通信（IPC）机制来实现，包括管道、消息队列、信号量和共享内存等方式。消息传递是一种相对安全的通信方式，因为进程或线程之间无法直接访问对方的内存。

文件映射：文件映射是指将文件映射到进程或线程的地址空间中，以实现不同进程或线程之间的共享数据。文件映射可以使用内存映射文件（MMAP）机制来实现，这种方式将文件映射到进程或线程的地址空间中，使得多个进程或线程可以共享同一文件的数据。

Socket通信：Socket通信是指使用网络套接字（Socket）实现进程或线程之间的通信。Socket通信可以在同一台主机上的不同进程或线程之间进行，也可以在不同主机之间进行。Socket通信是一种常见的跨平台通信方式，可以实现高效的数据传输和共享。

5、查找算法

线性折半哈希 红黑树 树形

 6、I/O多路复用机制

I/O多路复用（I/O Multiplexing）是指通过一种机制，使一个进程能够同时监控多个I/O操作。在I/O多路复用机制下，一个进程可以等待多个I/O事件的发生，而无需阻塞在单个I/O操作上。

常用的I/O多路复用机制包括以下几种：

1. select：select是一种基于文件描述符的I/O多路复用机制。使用select机制，进程可以同时监控多个文件描述符，当其中任意一个文件描述符就绪（可读或可写）时，select函数会返回并通知进程。

2. poll：poll是一种基于文件描述符的I/O多路复用机制，与select类似。不同之处在于，使用poll机制时，需要将文件描述符数组传递给poll函数，而不是使用select中的fd_set数据结构。

3. epoll：epoll是Linux专用的高效I/O多路复用机制。使用epoll机制，进程可以同时监控大量的文件描述符，当其中任意一个文件描述符就绪时，epoll函数会返回并通知进程。epoll机制具有高效、可扩展等优点，已经成为Linux中常用的I/O多路复用机制。

使用I/O多路复用机制可以避免进程阻塞在单个I/O操作上，提高系统的并发能力。I/O多路复用机制适用于需要同时监控多个I/O事件的场景，例如网络编程中的服务器程序，可以使用I/O多路复用机制来同时处理多个客户端请求。

7、reactor

①整体是I/O复用 I/O非阻塞 （read write不会堵住）
②**I/O 多路复用监听**事件，收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程
③有acceptor类，socket类，socketio类，tcpconnection类，eventloop类，evtfd通信描述符，efd事件描述符
connect描述符。大部分都是组合关系
④计算类交由线程池中的工作线程去做，让线程池处理业务逻辑。让Reactor，也就是EventLoop处理IO操作，这样就可以处理计算量大的问题。

[(44 封私信 / 6 条消息) 如何深刻理解Reactor和Proactor？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/26943938)

作者：猿java
链接：https://www.zhihu.com/question/26943938/answer/2331283160
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



### **单 Reactor 单线程**

![img](https://pic1.zhimg.com/80/v2-0fba7896ad3d4814131bad8acad0c996_1440w.webp?source=1940ef5c)

Doug Lea的单线程模型

   由上图可以看出，单Reactor单线程模型中的 reactor、acceptor 和 handler 的功能都是由一个线程来执行的。reactor 负责监听客户端事件和事件分发，一旦有连接事件发生，它会分发给 acceptor，由 acceptor 负责建立连接，然后创建一个 handler。如果是读写事件，reactor 将事件分发给 handler 进行处理。handler 负责读取客户端请求，进行业务处理，并最终给客户端返回结果。

![img](https://pic1.zhimg.com/80/v2-5b7f229f0f954947075713e4191f747d_1440w.webp?source=1940ef5c)

单 reactor 单线程

### **2.单 reactor 多线程**

![img](https://pica.zhimg.com/80/v2-09f178b7e49497f2aa1262e464f4205b_1440w.webp?source=1940ef5c)

Doug Lea单 reactor 多线程

  该模型中，reactor、acceptor 和 handler 的功能由一个线程来执行，与此同时，会有一个[线程池](https://www.zhihu.com/search?q=线程池&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2331283160})，由若干 worker 线程组成。在监听客户端事件、连接事件处理方面，这个类型和单 rector 单线程是相同的，但是不同之处在于，在单 reactor 多线程类型中，handler 只负责读取请求和写回结果，而具体的业务处理由 worker 线程来完成。

![img](https://pica.zhimg.com/80/v2-fb3fd05d8d076fa5c02d9e22e646cea6_1440w.webp?source=1940ef5c)

单 reactor 多线程

### 3.主-从 Reactor 多线程

![img](https://pic1.zhimg.com/80/v2-9c074158f9fd04a6fd0d9518b8050741_1440w.webp?source=1940ef5c)

Doug Lea主-从 Reactor 多线程

在这个类型中，会有一个主 reactor 线程、多个子 reactor 线程和多个 worker 线程组成的一个线程池。其中，主 reactor 负责监听客户端事件，并在同一个线程中让 acceptor 处理连接事件。一旦连接建立后，主 reactor 会把连接分发给子 reactor 线程，由子 reactor 负责这个连接上的后续事件处理。那么，子 reactor 会监听客户端连接上的后续事件，有读写事件发生时，它会让在同一个线程中的 handler 读取请求和返回结果，而和单 reactor 多线程类似，具体业务处理，它还是会让线程池中的 worker 线程处理。刚才介绍的 Netty 使用的就是这个类型。

![img](https://pic1.zhimg.com/80/v2-8b2591c3ef01973876d0f934130f3346_1440w.webp?source=1940ef5c)

主-从Reactor多线程



### nginx

nginx是多进程模型，master进程不处理网络IO，每个Wroker进程是一个独立的[单Reacotr单线程模型](https://www.zhihu.com/search?q=单Reacotr单线程模型&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2331283160})。，详情参考官方文档：[Inside NGINX: Designed for Performance & Scalability](https://link.zhihu.com/?target=https%3A//www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)

为什么服务器不采用开源的NGINX  而是自己去搭建怎么回答哇  NGINX还自带缓存 

你说用了呀，结合起来使用的哟  静态资源的获取可以使用Nginx部署

动态的API服务是使用workflow来充当API网关的

面试中问你在工作中怎么用Redis和MySql数据库怎么回答？都具体做些什么？存储什么数据？

这是要理解关系型和非关系型数据库的区别

从架构的角度来考虑，workflow可以做比较核心的事儿，Nginx做它比较擅长的事儿，结合使用会更完美，这个不是工作量的问题~

8、代理模式和实例 pimpl模式和适配器proxy模式

代理模式（Proxy Pattern）：代理模式用于为另一个对象提供一个替代品或占位符以控制对这个对象的访问。代理对象和原有对象具有相同的接口，可以替代原有对象被客户端使用，代理对象在执行客户端请求时，可以在请求前或请求后执行一些额外的操作，例如权限控制、缓存等。

Pimpl模式（Pointer to Implementation Pattern）：Pimpl模式也称为“编译期实现模式”，是一种将类的实现细节隐藏起来的方式。Pimpl模式通过将类的实现细节封装在指向实现类的指针中，从而避免了头文件暴露实现细节的问题，同时也可以避免不必要的编译依赖性和重编译的问题。

适配器模式（Adapter Pattern）：适配器模式用于将一个类的接口转换成客户端所期望的另一个接口，从而使原本由于接口不兼容而不能一起工作的类可以协同工作。适配器可以在不改变原有代码的情况下，为原有对象提供一些额外的功能或适配其他接口。

9、快排

```c
void QuickSort(int* aimArray, int low, int high) {
	int 
```

10、各个字段的大小（64位）
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688730277830-5aa5ad3d-2bb3-4744-a854-cb91cb51f5fc.png#averageHue=%23fafafa&clientId=ub5959bb6-3cc5-4&from=paste&height=317&id=ucc7daf7d&originHeight=396&originWidth=1213&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=19104&status=done&style=none&taskId=u84ab36f3-99ed-49d9-9f19-a91800ce615&title=&width=970.4)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688730298294-6a98f488-5bba-4f92-bb9a-843672852a99.png#averageHue=%23292d35&clientId=ub5959bb6-3cc5-4&from=paste&height=245&id=u32ecc175&originHeight=306&originWidth=1211&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=41755&status=done&style=none&taskId=uf9ea6810-9732-4056-8b99-1ba57d3ee16&title=&width=968.8)

11、vlan的相关知识

12、
unsigned int num = 1024;
bool flag = *( (bool*)&num);

13、初始化列表
初始化列表：以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个"成员变量"后面跟 一个放在括号中的初始值或表达式
初始化只能进行一次，而构造函数体内可以多次赋值。

14、深拷贝浅拷贝二叉树，二叉树的遍历
```c
#include <iostream>

class Node {
public:
    int data;
    Node* left;
    Node* right;

    Node(int value) : data(value), left(nullptr), right(nullptr) {}
};

// 深拷贝二叉树
Node* deepCopyTree(const Node* root) {
    if (root == nullptr) {
        return nullptr;
    }

    Node* newNode = new Node(root->data);
    newNode->left = deepCopyTree(root->left);
    newNode->right = deepCopyTree(root->right);

    return newNode;
}

// 浅拷贝二叉树
Node* shallowCopyTree(const Node* root) {
    return root;
}

// 打印二叉树（先序遍历）
void printTree(const Node* root) {
    if (root == nullptr) {
        return;
    }

    std::cout << root->data << " ";
    printTree(root->left);
    printTree(root->right);
}
```

15、valgrind具体用过吗，怎么用

1）编译程序t2.c
gcc -Wall t2.c -g -o t2
2）使用Valgrind检查程序BUG
valgrind --tool=memcheck --leak-check=full ./t2
\3) 运行结果如下：
==3058== Memcheck, a memory error detector
==3058== Copyright (C) 2002-2012, and GNU GPL'd, by Julian

16、协程

**协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程**，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。

17、项目的并发量和 数据大小

1000tps 和一百万 条数据

18、redis显性设置定时清理

19、类模板里有函数模板，这个函数需要怎么定义
两个模板都声明一下

20、智能指针的裸指针直接回收会发生什么
如果你直接回收智能指针所包装的裸指针，会导致未定义行为。智能指针在其析构函数中负责释放所管理的内存，而直接回收裸指针可能会导致重复释放内存或者释放非法内存。
智能指针通常会使用引用计数或其他方式来跟踪有多少智能指针共享同一块内存。当最后一个智能指针离开作用域或被显式销毁时，智能指针会自动调用析构函数，将关联的内存释放。

20线程的优先级怎么确定

线程的优先级决定了在多线程环境中，操作系统分配CPU资源的顺序。在Java中，线程的优先级可以通过Thread类的setPriority(int priority)方法设置，优先级的范围是1到10，其中1是最低优先级，10是最高优先级。

线程的优先级应该根据任务的紧急程度和重要性来确定。通常，如果一个线程执行的任务比其他线程更加紧急和重要，则可以将其优先级设置为较高的值。相反，如果一个线程执行的任务相对不那么紧急和重要，则可以将其优先级设置为较低的值。

需要注意的是，线程优先级的设置并不能保证线程一定会优先执行，因为线程调度也受到操作系统的调度算法和其他因素的影响。因此，应该避免过度依赖线程优先级来控制程序的执行顺序，而是应该采用其他机制来确保线程执行的顺序和正确性，例如使用锁、信号量、条件变量等并发控制机制。

在C++中，线程的优先级可以通过操作系统提供的API函数来设置。在Windows操作系统中，可以使用SetThreadPriority函数来设置线程的优先级，它的参数可以是THREAD_PRIORITY_IDLE、THREAD_PRIORITY_LOWEST、THREAD_PRIORITY_BELOW_NORMAL、THREAD_PRIORITY_NORMAL、THREAD_PRIORITY_ABOVE_NORMAL、THREAD_PRIORITY_HIGHEST或THREAD_PRIORITY_TIME_CRITICAL这7个常量，分别代表空闲、最低、低于正常、正常、高于正常、最高、时间关键等7个优先级。

在Linux操作系统中，可以使用pthread_setschedparam函数来设置线程的优先级，它的参数包括线程ID、调度策略和优先级等信息。

需要注意的是，与Java不同，C++标准库并没有提供原生的多线程支持，需要使用操作系统提供的API函数或第三方库来实现多线程编程。同时，线程优先级的设置也受到操作系统调度算法和其他因素的影响，不能完全保证线程一定会按照优先级顺序执行。因此，在编写多线程程序时，需要注意正确使用同步机制和避免过度依赖线程优先级来控制程序的执行顺序。

21、redis的存储形式，大小

Redis是一种基于内存的键值存储系统，它将所有的数据都存储在内存中，因此读写速度非常快。Redis支持多种数据类型的存储，如字符串、哈希表、列表、集合和有序集合等。

以下是Redis支持的数据类型及其存储形式和大小：

1. 字符串（string）：存储单个字符串或二进制数据，最大512MB。字符串类型的值可以是整数、浮点数或字符串。

2. 哈希表（hash）：存储键值对的无序集合，最大2^32-1个键值对。哈希表类型适用于存储对象的多个属性。

3. 列表（list）：存储有序的字符串列表，最大2^32-1个元素。列表类型适用于存储按顺序排列的数据，如日志信息和消息队列。

4. 集合（set）：存储无序的字符串集合，最大2^32-1个元素。集合类型适用于存储唯一的数据，如网站访问IP地址记录。

5. 有序集合（sorted set）：存储有序的字符串集合，最大2^32-1个元素。有序集合类型适用于存储带有权重的数据，如排行榜和计分系统。

需要注意的是，Redis是一个基于内存的存储系统，因此数据的大小受到可用内存的限制。如果数据量过大，可能会导致Redis内存不足而出现性能问题。为了解决这个问题，Redis提供了持久化机制，可以将数据定期写入磁盘中，以避免数据丢失和内存不足的问题。

22、从文件里读数据，判定数据类型，再放到另一文件里        代码

#include <fstream>
#include <iostream>
#include <string>

using namespace std;

int main() {
    ifstream input("input.txt");  // 打开输入文件
    ofstream output("output.txt");  // 打开输出文件

    string line;  // 存储读取的每一行数据
    while (getline(input, line)) {  // 逐行读取输入文件中的数据
        if (line.empty()) {  // 跳过空行
            continue;
        }
    
        // 判断数据类型
        if (line[0] == '+' || line[0] == '-' || isdigit(line[0])) {  // 整数类型
            output << "Integer: " << stoi(line) << endl;  // 写入整数类型到输出文件
        } else if (line[0] == 't' || line[0] == 'f') {  // 布尔类型
            output << "Boolean: " << (line[0] == 't') << endl;  // 写入布尔类型到输出文件
        } else {  // 字符串类型
            output << "String: " << line << endl;  // 写入字符串类型到输出文件
        }
    }
    
    input.close();  // 关闭输入文件
    output.close();  // 关闭输出文件
    
    return 0;
}

23、求普通数组长度sizeof（a）/sizeof（a[0]）

24、做量化交易系统需要注意的点

25、c++如何内存共享和进程管理的

C++提供了多种方式来实现内存共享和进程管理，以下是一些常见的方法：

1. 共享内存：使用共享内存可以让多个进程共享同一块内存区域，从而实现进程间的数据通信和共享。在C++中，可以使用操作系统提供的API函数（如Windows下的CreateFileMapping和MapViewOfFile函数）或第三方库（如Boost.Interprocess库）来实现共享内存。

2. 管道（Pipe）：管道是一种进程间通信机制，用于在两个进程之间传输数据。在C++中，可以使用操作系统提供的API函数（如Windows下的CreatePipe和ReadFile/WriteFile函数）或第三方库（如Boost.Interprocess库）来实现管道。

3. 进程管理：在C++中，可以使用操作系统提供的API函数（如Windows下的CreateProcess和WaitForSingleObject函数）或第三方库（如Boost.Process库）来创建和管理进程。这些函数和库可以实现进程的创建、销毁、等待、通信等功能，从而实现进程间的协作和数据交换。

需要注意的是，使用内存共享和进程管理需要考虑进程安全性和数据一致性等问题，同时也需要考虑操作系统的兼容性和可移植性。因此，在实际应用中，需要根据具体需求和环境选择合适的方法来实现内存共享和进程管理。

26、手搓链表 然后实现struct list * swap(struct list * List, sturct node_s * from, struct node_s * to)
```c
#include <iostream>

class Node {
public:
    int data;
    Node* next;

    Node(int value) : data(value), next(nullptr) {}
};

class LinkedList {
private:
    Node* head;

public:
    LinkedList() : head(nullptr) {}

    void addNode(int value) {
        Node* newNode = new Node(value);
        if (head == nullptr) {
            head = newNode;
        } else {
            Node* curr = head;
            while (curr->next != nullptr) {
                curr = curr->next;
            }
            curr->next = newNode;
        }
    }


    Node* getNode(int value) {
        Node* curr = head;
        while (curr != nullptr) {
            if (curr->data == value) {
                return curr;
            }
            curr = curr->next;
        }
        return nullptr;
    }

    void swap(Node* from, Node* to) {
        if (from == nullptr || to == nullptr || from == to) {
            return;
        }
        Node* prevFrom = nullptr;
        Node* currFrom = head;
        while (currFrom != nullptr && currFrom != from) {
            prevFrom = currFrom;
            currFrom = currFrom->next;
        }
        Node* prevTo = nullptr;
        Node* currTo = head;
        while (currTo != nullptr && currTo != to) {
            prevTo = currTo;
            currTo = currTo->next;
        }
        if (currFrom == nullptr || currTo == nullptr) {
            return;
        }
        if (prevFrom != nullptr) {
            prevFrom->next = currTo;
        } else {
            head = currTo;
        }
        if (prevTo != nullptr) {
            prevTo->next = currFrom;
        } else {
            head = currFrom;
        }
        Node* temp = currTo->next;
        currTo->next = currFrom->next;
        currFrom->next = temp;
    }
};

int main() {
    LinkedList list;
    list.addNode(1);
    list.addNode(2);
    list.addNode(3);
    list.addNode(4);
    list.addNode(5);

    std::cout << "Original List: ";
    list.printList();

    Node* from = list.getNode(2);
    Node* to = list.getNode(4);

    if (from != nullptr && to != nullptr) {
        list.swap(from, to);
        std::cout << "Swapped List: ";
        list.printList();
    } else {
        std::cout << "Nodes not found in the list." << std::endl;
    }

    return 0;
}

```


27、项目并发量，版本号，可执行文件大小
大小30m左右，离线部分，客户端，服务端
QPS
并发连接总数: 10500

28、测试：自测冒烟通过后提测
开发通过项目管理工具（云效）对接
主流的自动化打包测试流程CICD
项目的具体流量多大：1w   
如何部署的：自动化脚本

29、如果是char s[4];
char s[0] = 
char s[1] = 
char s[2] = 
char s[3] = 
strlen(char)多少

30、int fun（） const  这种函数构成重载吗。函数内部有什么不同
在C++中，函数的重载是指在同一作用域内存在多个同名函数，但它们的参数列表不同。在你提供的函数声明 int fun() const 中，如果存在另一个同名函数 int fun()，那么这两个函数将构成重载。
函数内部的 const 关键字在这里是一个重要的区别。它被称为成员函数的 const 修饰符，用于指示函数是一个常量成员函数。具有 const 修饰符的成员函数保证在函数内部不会修改类的成员变量（非 mutable 成员除外），这也是为什么 const 成员函数在常量对象上可以被调用。

31、函数模板声明和初始化为什么不能分开放

在C++中，函数模板的声明和定义必须放在同一个文件中，不能将其分开放在不同的文件中。这是因为C++编译器在编译时需要通过函数模板的声明来确定函数模板的参数类型和返回类型，从而生成正确的代码。如果函数模板的声明和定义分开放在不同的文件中，编译器将无法确定函数模板的参数类型和返回类型，也就无法生成正确的代码。

当然，可以将函数模板的声明和定义放在同一个头文件中，然后在需要使用该函数模板的文件中包含这个头文件即可。这样，编译器就可以在编译时看到函数模板的声明和定义，从而生成正确的代码。

需要注意的是，如果一个函数模板在多个文件中都被包含了，可能会出现符号重定义的问题。为了避免这个问题，可以使用inline关键字将函数模板声明为内联函数，或者使用extern关键字将函数模板声明为外部函数。使用内联函数可以在编译时将函数模板的代码插入到调用它的代码中，从而避免符号重定义的问题。使用外部函数可以将函数模板的定义放在一个单独的源文件中，从而避免符号重定义的问题。

32、虚函数怎么使用，基类和派生类之间的操作

虚函数是C++中实现多态性的一种机制，通过使用虚函数，可以在基类和派生类之间实现多态性，从而使程序更加灵活和可扩展。

虚函数的定义和使用方式如下：

1. 在基类中定义虚函数，使用virtual关键字修饰，如：

```cpp
class Shape {
public:
    virtual void draw() const;
};
```

2. 在派生类中重写基类的虚函数，使用override关键字修饰，如：

```cpp
class Circle : public Shape {
public:
    void draw() const override;
};
```

3. 在程序中通过基类指针或引用来调用虚函数，如：

```cpp
Shape* shape = new Circle();
shape->draw();
```

在上述代码中，通过基类指针shape来调用虚函数draw，由于shape指向的是Circle对象，因此最终会调用Circle类中的draw函数。

需要注意的是，虚函数只能在类的成员函数中使用，而不能在静态成员函数、构造函数和析构函数中使用。此外，虚函数的调用会带来一定的性能开销，因为需要通过虚表来查找函数地址，因此在实际应用中需要考虑性能和效率的问题。

基类和派生类之间的操作可以通过虚函数来实现多态性。当基类指针或引用指向派生类对象时，可以调用派生类中的虚函数，从而实现基类和派生类之间的多态性。例如，在上述代码中，Shape类是一个基类，Circle类是Shape类的派生类，通过将Circle对象赋值给Shape指针，可以实现基类和派生类之间的多态性。此外，还可以通过在派生类中重写基类的虚函数来实现派生类的特定操作。

33、去除字符串中的空格
> [**https://wenku.baidu.com/view/584fc8131411cc7931b765ce0508763231127495.html?_wkts_=1689145912839&bdQuery=c%2B%2Bregex%E6%B8%85%E7%A9%BA%E7%A9%BA%E6%A0%BC**](https://wenku.baidu.com/view/584fc8131411cc7931b765ce0508763231127495.html?_wkts_=1689145912839&bdQuery=c%2B%2Bregex%E6%B8%85%E7%A9%BA%E7%A9%BA%E6%A0%BC)



34、share指针调用的时候，引用计数会+1，返回的时候也会+1

35、redis
我们通过配置redis.conf中的appendonly yes就可以打开AOF功能。如果有写操作（如SET等），redis就会被追加到AOF文件的末尾。AOF，英文是Append Only File，即只允许追加不允许改写的文件。
> [https://blog.csdn.net/JAVAMysql111/article/details/123171055](https://blog.csdn.net/JAVAMysql111/article/details/123171055)

36、explain 慢查询

慢查询（Slow Query）是指在数据库中花费时间较长的查询操作。慢查询可能会导致数据库性能下降，影响用户体验和系统的可用性。

在数据库中，通常会设置一个阈值来定义慢查询的时间阈值。如果一个查询操作的执行时间超过了这个阈值，那么就认为它是一个慢查询。根据具体情况，慢查询的时间阈值可以设置为几十毫秒或几秒钟。

慢查询可能会出现的原因有很多，包括但不限于：

1. 数据库表没有正确的索引：在查询大表时，如果没有正确的索引，那么查询的时间复杂度将会是O(n)，导致查询耗时较长。

2. 数据库服务器负载过高：如果数据库服务器负载过高，那么查询操作的等待时间将会变长，导致查询耗时较长。

3. 查询语句不够优化：查询语句的性能很大程度上取决于它的写法。如果查询语句没有优化，那么查询的时间复杂度将会比较高。

4. 数据库表设计不合理：如果数据库表的设计不合理，那么查询操作的执行时间将会比较长。

为了避免慢查询对数据库性能的影响，可以采取以下措施：

1. 添加合适的索引：对于大表查询，可以通过添加合适的索引来优化查询性能。

2. 优化查询语句：对于复杂的查询语句，可以通过优化查询语句的写法来提高查询性能。

3. 增加数据库服务器资源：如果数据库服务器负载过高，可以增加服务器资源来提高查询性能。

4. 定期监控和优化数据库性能：可以通过定期监控数据库性能，及时发现慢查询，进行优化，提高数据库的性能。

总之，慢查询是数据库中常见的性能问题之一，需要及时发现和解决，从而保证数据库的性能和稳定性。

37、用动态库还是静态库，区别和用的次数
我们用的都是静态库
一般来说，如果多个应用程序需要共享同一个库或者需要动态更新库，使用动态库更为合适。而如果库的使用较为固定且不需要共享，使用静态库可能更简单和高效。选择动态库或静态库的关键是根据具体的需求和应用场景来决定

38、reactor peator

39、不用锁的话用![image.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1689171063633-e00f730a-5c1d-4e3b-a5ae-87378efc2ada.png#averageHue=%23e8e5cc&clientId=u0c515707-11cc-4&from=paste&height=60&id=u744a596e&originHeight=75&originWidth=293&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=17716&status=done&style=none&taskId=ubec155fe-ef91-49da-bd57-7a56b878dc1&title=&width=234.4)

40、Lru
```c
#include <iostream>

#include <list>
#include <map>

using namespace std;

class Lru
{
public:
    Lru(int size)
    :_size(size)
    {
    }

    void add(int data)
    {
        if (_size < lru.size())
        {
            lru.push_front(data);
            pos[data] = lru.begin();
        } else {
            lru.pop_back();
            //pos.erase()
            lru.push_front(data);
            pos[data] = lru.begin();
        }
    }

    void update(int data)
    {
        lru.push_front(data);
        lru.erase(pos[data]);
        pos[data] = lru.begin();
    }

private:
    size_t _size;
    list<int> lru;
    map<int,list<int>::iterator> pos;
};



int main()
{
    std::cout << "Hello world" << std::endl;
    return 0;
}
```


41、算法：做一个函数CheckDate(date)，给定任意日期 date，算出该日期是否已经过了本月的第三个周五示例:CheckDate(20180720)输出结果为false

42、算法：倒序字符串

43、算法：反转链表

![7d34819e8329958ff3b2270a7d90135.png](https://cdn.nlark.com/yuque/0/2023/png/35318823/1688899629335-f94feba7-ece8-4bf7-ab42-80094c1439d4.png#averageHue=%23c1b298&clientId=u9ec43271-12f0-4&from=paste&height=799&id=u371afb47&originHeight=999&originWidth=1915&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=487256&status=done&style=none&taskId=u1f60d5e8-b7be-45f2-afc9-49f65c6ac06&title=&width=1532)

![ac574b1abd8c34a5e7f0e92076c64cd.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/35318823/1689172709372-6acb6a69-e0ae-43db-9d20-6fe94e9a3459.jpeg#averageHue=%233e5060&clientId=u0c515707-11cc-4&from=paste&height=1286&id=uc4403f47&originHeight=1608&originWidth=1080&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=235366&status=done&style=none&taskId=uf745f632-034a-412f-b3c9-f38a65db85a&title=&width=864)

44、cppjieba和simhash（中的cppjieba）的keywordextractor：新版旧版的返回值不一样，新版返回bool模型，旧版返回void类型

45、
命令控制退出：
服务器可以通过特定的命令或控制指令来执行退出操作。
这可以是自定义的管理命令，或者通过与服务器进行交互的控制台或管理接口来发送退出指令。
需要注意的是，服务器退出时应该确保数据的一致性和资源的释放。在退出之前，可以执行必要的清理操作，如关闭数据库连接、保存临时数据等。此外，还应该处理未完成的请求和事务，以确保系统的稳定性和数据的完整性。
优雅退出
fork和管道通信，找是否是exit

### （三）经验总结
1、**海投海面，以战养战**。心态和应试技巧会越来越好。我周二面了7家，一家一小时，从早到晚。有志者事竟成
2、**简历突出**，将王道项目包装成一个非常合理的大项目的子项目，让别人一眼看不出来这是搜索引擎和网盘
3、**面试把握主动权**，别人让你介绍项目，就从头到位给他讲的事无巨细。并抛出一两个技术名词比如epoll、线程池、redis和死锁，这种他们熟悉的内容，让他们来问，一问就回答的停不下来，让他们听麻
（他们是没法通过你说的东西来找到里面一些逻辑瑕疵和功能瑕疵的，只要自信地喷涌而出，他们只会愣着听你说，而且他们的时间很宝贵，说完他们也没有啥想问的了）
4、自己眼神**互动**，说话有气，肢体动作。也要观察面试官的反应，笑没笑，点头没点头，附和没附和，如果都没有，要考虑到自己说错了，转头说其实这方面我也是在学习中，我很短的时间内了解了这些内容，可能会有一些不准确的地方。之后让他来说，然后附和着他，让他说的有劲，然后重复他的答案，他会很开心。
5、**自信**和**谦虚**都要有，不要硬不懂装懂、
6、**把主题往自己会的地方引**，问到边缘知识，一句带过之后说自己对某某方面更了解，然后开始疯狂说
7、八股文不会的可以**试探出答案**，先说自己记不清了，然后问答案a对不对，他不说话那就是不对。他嗯，或者积极态度，那就是对，继续往下讲
8、**对症下药，**知道他的需求，他们想要什么样的人，你就立什么样的人设，要做到说谎不眨眼。并保持对贵公司的热爱。
9、**真诚**是必杀技，要示弱，示惨，示好
10、要懂**礼貌懂礼仪**。非常感谢，您辛苦了，不好意思，冒昧打扰之类的话要长挂嘴边
11、**归纳总结**，总结自己的面试题，面试经验
12、遇到自己真喜欢的公司，去了解，自我介绍的时候说自己对这方面的兴趣与对公司的了解和热情，非常有用

### （四）额外赠送（截止时间7月31日）
1、本人面了10天，投了1000家，面了40家，通过率80%，收到10多个offer，对投简历、面试和谈薪很有经验
1、王道熟人免费无条件答疑，修改简历，帮助面试
2、其他道友需要帮助20元一次





在公司开发中，如何保证自己的代码质量怎么回答呀？

保证自己的代码质量是每个开发人员都应该努力做到的一件事情。以下是一些建议，可以帮助您在公司开发中保证自己的代码质量：

1. 遵循最佳实践：了解并遵循最佳的编码实践，例如使用有意义的变量名和函数名、遵循 SOLID 原则、编写可读性强的代码等等。

2. 写单元测试：编写单元测试可以帮助您确保代码功能正确性，也可以提高代码质量。在编写代码时，始终牢记测试驱动开发（TDD）的原则，即编写测试用例，编写实现代码，然后运行测试用例。

3. 代码审查：让同事或主管进行代码审查可以帮助发现潜在的错误和问题，并提供改进意见。这是一种非常好的学习机会，可以帮助您在开发过程中不断提高自己的编程技能。

4. 注重代码可维护性：将注意力放在代码的可维护性上，这将有助于确保代码在未来能够轻松地被修改和维护。这包括避免编写过于复杂的代码、及时清理无用的代码、避免重复的代码等。

5. 学习新技术和工具：保持学习新技术和工具的态度，这将帮助您改进代码质量。了解新技术和工具的使用方法，可以帮助您更高效地编写代码，提高生产效率。

6. 遵循公司的代码规范：了解公司的代码规范，并遵循它们。这将有助于确保您的代码与团队的其他成员编写的代码一致，并保证代码的一致性和可读性。

FAE是英文Field Application Engineer——现场应用工程师的简称。很多人一听到FAE，第一印象就是个做技术支持的，不是研发，感觉学不到啥技术没啥前途。蓝宝王的第一份工作就是做FAE的，面试官说是做技术支持，当时心都凉了半截。后来蓝宝王做了十年FAE，再说FAE这个工作没技术，这其实是一种很深的误解。

当然，首先需要区分一下，如果是代理商，方案公司，外包公司的FAE，这个确实是没啥前途，直接劝退毫不惋惜。做FAE，一定要做芯片原厂的FAE，这个岗位能学到技术，也很有前途。

几乎全世界所有的芯片公司都有数量庞大的FAE团队，但可能名字有些许差别。比如高通、英伟达的叫CE（Customer Engineer），TI的叫AE（Application Engineer），联发科和很多台系芯片厂也大多叫AE，大陆的芯片厂商基本叫FAE或者技术支持。这里除了TI的AE需要背销售业绩之外，其他厂的FAE属于技术部门，不需要背销售业绩。

因为你的芯片要推给客户，而芯片这么高精尖的产品，并不是你随随便便看个说明书就会用的。而且，就算你的技术说明写得多么通俗易懂，客户的工程师往往不带脑子，更喜欢有人手把手教，手把手喂。所以，只要是芯片公司，FAE团队是必不可少的。

FAE工程师的技术虽然比不上芯片公司研发，但一定比终端公司的“研发”强。

FAE的工作职责一般包括三部分内容：

1.提供技术支持，解答疑问；

2.解决客户产品开发过程中的bug（自己解决或者协调内部研发解决）；

3.开发客制化的需求（自己开发或者协调内部研发开发）。

那回到本文的正题：FAE的前途在哪里？

**1.相对于终端客户的研发工程师，芯片原厂的FAE能接触到更多的核心技术。**

以手机上的指纹模块或者蓝牙模块为例，手机厂的人只能接触到Android和Linux的这层的开源代码，核心的部分都被芯片厂so库封装起来了。而芯片厂的FAE可以看到so库的代码，还可以看到芯片内部的firmware代码。另外，手机厂作为甲方，有些需求明明可以自己做的，也会依赖于芯片厂去实现。还有，新技术也由芯片厂推动研发的，FAE也是率先接触，然后再推给手机厂的工程师，比如蓝牙5.0，超声波指纹识别。

**2.相对于芯片公司内部的研发工程师，FAE的技术领域和知识面更广。**

在芯片公司内部，研发往往都是负责一块很细的领域，不可否认他们在这个细分领域是专家，但超出自己领域的技术就不懂。以蓝牙为例，有专门负责蓝牙音频A2DP协议的，有专门负责低功耗BLE协议的，有专门负责蓝牙通话SCO协议的。而作为一个蓝牙FAE，基本上这些协议全部都要接触，因为在客户端，基本什么问题会报，什么问题都要处理。而如果向一个A2DP研发请教关于BLE协议的问题，大概率是回答不了。据说华为厂有研发五年内一直在搞I2C协议，个人觉得这个也太窄了。

**3. FAE能积累更丰富的经验**

经验这东西，真的不是花钱就能买到的，也不是多看几本书就能学到的，全靠实战点点滴滴积累。有些问题，你没遇到过就是没遇到过，不管你再天资聪颖，学富五车，哈佛耶鲁全球TOP10渣硕毕业也没用。FAE支持众多客户，众多项目，所谓林子大了，什么鸟都有，什么客户都有，你的客户会报各种各样的问题以增加你的见识，丰富你的经验。这就跟医生治病一样，经验越丰富，医术越高。

**4. FAE能积累更丰富的人脉**

跟研发天天待在办公室不出门，不直接接触客户不同，FAE需要接触不同的客户，经常出去出差，拓展更大的圈子，或许哪天改变你命运的机会就来了。另外，FAE也更容易创业。

所以，从职业生涯的角度来看，一个当过原厂FAE的人去终端产品厂一般会很吃香。君不见，oppo/vivo有多少工程师来自MTK。

从辩证的角度来看，以上种种付出的代价就是牺牲技术的深度。在有限的生命内，技术的深度和广度是一对不可调和的矛盾，有深度没广度在职业选择时未必见得有多好。

很多人，尤其是应届生找工作的时候，十分顽固地一定要做研发，一看到技术支持就打退堂鼓。其实，研发也要区分是哪里的研发，技术支持也要区分是哪里的技术支持。单从技术角度来说，芯片原厂FAE的技术能虽然弱于芯片原厂的研发，但肯定要强于终端公司的研发。

我是蓝宝王，国际芯片大厂资深FAE，欢迎咨询。

![自我介绍与引擎 话术](C:\Users\范劲松\Desktop\面试话术\自我介绍与引擎 话术.png)



为什么选择fae工程师

作为一名FAE（Field Application Engineer）工程师，我认为我的角色是将客户需求和公司产品之间的桥梁。我可以通过深入了解客户的需求和痛点，为他们提供定制化的解决方案，并协调公司的技术团队来提供技术支持和服务。

我选择成为一名FAE工程师的原因有以下几点：

1. 对技术的热情：我对技术有强烈的兴趣，喜欢解决技术难题和探索新技术。作为一名FAE工程师，我可以与各种客户接触，了解他们的需求和挑战，并在解决方案的设计和实现过程中不断学习和发展自己的技术能力。

2. 对客户服务的热情：我喜欢与客户进行沟通和交流，并为他们提供高质量的服务。作为一名FAE工程师，我可以与各种客户打交道，了解他们的需求和痛点，并帮助他们解决技术问题，提高他们的业务效率和竞争力。

3. 对团队合作的热情：我认为团队合作是实现成功的关键。在我之前的工作经验中，我在多个团队中工作并取得了成功。作为一名FAE工程师，我可以与公司的技术团队紧密合作，为客户提供最佳的解决方案，同时也可以为公司的产品改进提供重要的反馈和建议。

综上所述，我选择成为一名FAE工程师，是因为我对技术、客户服务和团队合作有着强烈的热情，并且相信这是一个非常有挑战和发展机会的职业。

怎么使用reactor搭建一个检索引擎

**要用C++搭建一个检索引擎，可以考虑以下几个步骤：**

1. 数据存储

首先需要将数据存储到一个数据结构中，以便于进行检索。可以使用类似于哈希表、红黑树、Trie树等数据结构来存储数据。需要注意的是，数据结构的选择应该基于数据的特点和检索需求，以保证检索的效率。

2. 数据索引

接下来需要将数据索引化，以便于进行快速的检索。可以使用类似于倒排索引、前缀树等数据结构来实现数据的索引化。需要注意的是，索引结构的设计应该基于数据的特点和检索需求，以保证检索的效率。

3. 检索实现

一旦数据被索引完成，就可以开始进行检索了。可以使用类似于字符串匹配、二分查找、哈希查找等算法来实现检索功能。需要注意的是，检索算法的选择应该基于数据的特点和检索需求，以保证检索的效率。

4. 结果处理

最后需要将检索结果进行处理，并返回给用户。可以使用C++提供的STL库来对检索结果进行排序、去重、分页等操作，以便于在返回给用户之前进行必要的处理。

需要注意的是，搭建一个检索引擎不仅仅是一个技术实现问题，还需要考虑到如何设计索引结构、如何分析用户查询、如何优化搜索算法等问题。因此，在实际开发中，需要综合考虑各种因素，并进行适当的调整和优化。

**怎么保证tcp/ip不丢包**

在 TCP/IP 协议中，为了保证传输的可靠性，TCP 协议通过一系列的机制来保证数据的完整性和有序性，其中包括：

1. 序列号和确认应答机制：TCP 协议会为每个数据包分配一个序列号，并在接收方收到数据包后发送一个确认应答包，以保证每个数据包都被正确地接收。

2. 滑动窗口机制：TCP 协议会维护一个滑动窗口，用于调整发送方和接收方的发送和接收速率，以保证数据包的有序性和完整性。

3. 超时重传机制：如果发送方没有收到确认应答包，则会重新发送该数据包，以保证数据包的可靠性。

4. 流量控制和拥塞控制机制：TCP 协议会根据网络状况和带宽情况来调整发送和接收速率，以避免网络拥塞和数据包丢失。

除了 TCP 协议内置的机制，还可以通过其他方式来提高数据传输的可靠性和稳定性，例如：

1. 使用数据校验和：在数据包中添加校验和，以确保数据包在传输过程中没有被修改或损坏。

2. 使用数据压缩技术：对传输的数据进行压缩，可以减少数据包的大小，从而降低数据包丢失的概率。

3. 使用数据冗余技术：在传输的数据中添加冗余信息，可以在数据包丢失时通过冗余信息进行恢复。

需要注意的是，即使使用了以上的一些机制和技术，也无法完全避免数据包丢失的情况。在实际应用中，可以通过多次重传、数据包分片等方式来提高数据传输的可靠性和稳定性。

地平线感知：对感知有了解在下游反应感知有问题时，需要去处理，主要是做感知的 

第二责任可能是效率工具开发：算法平台的通用类工具的开发 

